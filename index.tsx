/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
*/
import { render, h } from 'preact';
import { useState, useEffect, useMemo, useRef } from 'preact/hooks';
import htm from 'htm';
import { createClient, Session } from '@supabase/supabase-js';

const html = htm.bind(h);

// --- SUPABASE KONFIGURATION ---
// BITTE ERSETZE DIESE WERTE MIT DEINEN EIGENEN SUPABASE PROJEKT-DATEN
// Du findest sie in deinem Supabase Dashboard unter Project Settings > API
const supabaseUrl = 'https://wjlroiymmpvwaapboahh.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndqbHJvaXltbXB2d2FhcGJvYWhoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk5NDExNDMsImV4cCI6MjA3NTUxNzE0M30.oRDURzRrudCmNAis4ZACxPsbWJwdxHt5Nw49phamZO4';
const supabase = createClient(supabaseUrl, supabaseKey);


// --- KONFIGURATION ---
const CANCELLATION_WINDOW_HOURS = 24; // Stornierungen/Änderungen nur bis 24h vor dem Event möglich

const EVENT_CATEGORIES = {
    "Orchid": { titles: ["Welpenstunde"], locations: ["Welpenwiese"] },
    "LimeGreen": { titles: ["Level 2 - Grunderziehung"], locations: ["Der sichere Start"] },
    "SkyBlue": { titles: ["Level 3 - Fortgeschrittene"], locations: ["Hundeplatz Ascha"] },
    "Peru": { titles: ["Level 4 - Master Class"], locations: ["Hundeplatz Ascha"] },
    "Gold": { titles: ["Trainerstunde"], locations: ["Nach Absprache"] },
    "White": { titles: ["Theorie: Vorträge & Seminare"], locations: ["Hundeschule Innenbereich"] },
    "DarkKhaki": { titles: ["Praxis: Specials & Workshops"], locations: ["Stadtwald"] },
    "Tomato": { titles: ["Prüfungs-Stunden"], locations: ["Hundeschule Innenbereich"] }
};

const TRAINERS = ["Christian", "Sophie", "Sandra", "Susi", "Petra"];

// --- TYPEN & INTERFACES ---
interface Event {
    id: string;
    date: Date;
    title: string;
    location: string;
    total_capacity: number; // snake_case from db
    booked_capacity: number; // snake_case from db
    category: string;
    trainer: string | null;
}

interface Customer {
    id?: string; // Optional because it's generated by DB
    name: string;
    phone: string;
    dog_name: string; // snake_case from db
    email: string;
}

interface Booking {
    bookingId: string;
    customer: Customer;
    bookedEventIds: string[];
}


// --- API-SCHICHT (Supabase) ---
const api = {
    getEvents: async (): Promise<Event[]> => {
        const { data, error } = await supabase.from('events').select('*').order('date', { ascending: true });
        if (error) {
            console.error('Error fetching events:', error);
            throw error;
        }
        // Konvertiere Datum-Strings in Date-Objekte
        return data.map(e => ({...e, date: new Date(e.date)}));
    },
    saveBooking: async (customer: Omit<Customer, 'id'>, eventIds: string[]): Promise<Booking> => {
        // 1. Prüfe, ob Events noch verfügbar sind
        const { data: events, error: eventError } = await supabase.from('events').select('id, title, total_capacity, booked_capacity').in('id', eventIds);
        if (eventError) throw new Error("Fehler beim Prüfen der Events.");
        
        for (const eventId of eventIds) {
            const event = events.find(e => e.id === eventId);
            if (!event || event.booked_capacity >= event.total_capacity) {
                throw new Error(`Event "${event?.title || 'Unbekannt'}" ist leider ausgebucht.`);
            }
        }

        // 2. Prüfe, ob Kunde mit dieser E-Mail bereits existiert
        const { data: existingCustomer } = await supabase.from('customers').select('id').eq('email', customer.email.toLowerCase()).maybeSingle();
        if (existingCustomer) {
            throw new Error('Für diese E-Mail-Adresse existiert bereits eine Buchung. Bitte nutze die "Buchung verwalten"-Funktion.');
        }

        // 3. Erstelle neuen Kunden
        const { data: newCustomer, error: customerError } = await supabase.from('customers').insert({
            name: customer.name,
            phone: customer.phone,
            dog_name: customer.dog_name,
            email: customer.email.toLowerCase()
        }).select().single();

        if (customerError || !newCustomer) {
            throw new Error("Kunde konnte nicht erstellt werden.");
        }

        // 4. Erstelle neue Buchung
        const sanitizedDogName = customer.dog_name.trim().replace(/\s+/g, '-');
        const randomNumber = Math.floor(10000 + Math.random() * 90000);
        const newBookingId = `${sanitizedDogName}-${randomNumber}`;
        const { error: bookingError } = await supabase.from('bookings').insert({
            id: newBookingId,
            customer_id: newCustomer.id
        });

        if (bookingError) {
            // "Rollback" - lösche den eben erstellten Kunden
            await supabase.from('customers').delete().eq('id', newCustomer.id);
            throw new Error("Buchung konnte nicht erstellt werden.");
        }
        
        // 5. Verknüpfe Buchung mit Events
        const bookingEvents = eventIds.map(eventId => ({ booking_id: newBookingId, event_id: eventId }));
        const { error: bookingEventsError } = await supabase.from('bookings_events').insert(bookingEvents);

        if (bookingEventsError) {
             await supabase.from('customers').delete().eq('id', newCustomer.id); // Rollback
             await supabase.from('bookings').delete().eq('id', newBookingId); // Rollback
             throw new Error("Events konnten nicht zur Buchung hinzugefügt werden.");
        }
        
        // 6. Aktualisierung der `booked_capacity` wird nun vom DB-Trigger übernommen.

        return {
            bookingId: newBookingId,
            customer: newCustomer,
            bookedEventIds: eventIds
        };
    },
    getBookingById: async (bookingId: string): Promise<Booking | null> => {
        const { data, error } = await supabase
            .from('bookings')
            .select(`
                id,
                customer:customers (*),
                events:bookings_events (event_id)
            `)
            .eq('id', bookingId)
            .single();

        // Wenn keine Buchung gefunden wird, ein Fehler auftritt oder die Buchung keinen Kunden hat, null zurückgeben.
        if (error || !data || !data.customer) {
            if (error && error.code !== 'PGRST116') { // PGRST116 ist der Fehler "genau eine Zeile", was ok ist, wenn nichts gefunden wird.
                console.error('Error fetching booking:', error);
            }
            if (data && !data.customer) {
                console.error(`Buchung mit ID ${bookingId} gefunden, aber sie hat keinen zugehörigen Kunden.`);
            }
            return null;
        }
        
        // Bei einer "to-one"-Beziehung gibt Supabase ein Objekt zurück, kein Array.
        // Der vorherige Code ging fälschlicherweise von einem Array aus (data.customer[0]), was den Fehler verursachte.
        // FIX: The type from Supabase is inferred incorrectly as an array. Casting to `any` to align with runtime behavior where `data.customer` is an object.
        const customerData = data.customer as any;

        const booking: Booking = {
            bookingId: data.id,
            customer: {
                id: customerData.id,
                name: customerData.name,
                phone: customerData.phone,
                dog_name: customerData.dog_name,
                email: customerData.email,
            },
            bookedEventIds: data.events.map((be: any) => be.event_id),
        };
        return booking;
    },
    updateBooking: async (bookingId: string, newEventIds: string[]): Promise<Booking> => {
        const originalBooking = await api.getBookingById(bookingId);
        if (!originalBooking) throw new Error("Buchung nicht gefunden.");

        const originalEventIds = originalBooking.bookedEventIds;
        const addedIds = newEventIds.filter(id => !originalEventIds.includes(id));
        const removedIds = originalEventIds.filter(id => !newEventIds.includes(id));
        const now = new Date();

        const allEvents = await api.getEvents();

        // Stornierungen prüfen
        for (const removedId of removedIds) {
            const event = allEvents.find(e => e.id === removedId);
            if (event) {
                const hoursUntilEvent = (new Date(event.date).getTime() - now.getTime()) / (1000 * 60 * 60);
                if (hoursUntilEvent < CANCELLATION_WINDOW_HOURS) {
                    throw new Error(`Stornierung für "${event.title}" nicht möglich, da das Event in weniger als 24 Stunden beginnt.`);
                }
            }
        }

        // Neue Buchungen prüfen
        for (const addedId of addedIds) {
            const event = allEvents.find(e => e.id === addedId);
            if (!event || event.booked_capacity >= event.total_capacity) {
                throw new Error(`Event "${event?.title}" ist leider ausgebucht.`);
            }
        }

        // Änderungen in der Datenbank durchführen
        if (removedIds.length > 0) {
            await supabase.from('bookings_events').delete().eq('booking_id', bookingId).in('event_id', removedIds);
            // Die Aktualisierung der `booked_capacity` wird nun vom DB-Trigger übernommen.
        }

        if (addedIds.length > 0) {
            await supabase.from('bookings_events').insert(addedIds.map(id => ({ booking_id: bookingId, event_id: id })));
            // Die Aktualisierung der `booked_capacity` wird nun vom DB-Trigger übernommen.
        }
        
        return (await api.getBookingById(bookingId))!;
    },
    addEvent: async (newEventData: Omit<Event, 'id' | 'booked_capacity' | 'total_capacity'> & {totalCapacity: number, date: Date}): Promise<Event> => {
        const { data, error } = await supabase.from('events').insert({
            title: newEventData.title,
            location: newEventData.location,
            date: newEventData.date.toISOString(),
            total_capacity: newEventData.totalCapacity,
            category: newEventData.category,
            trainer: newEventData.trainer,
            booked_capacity: 0
        }).select().single();
        if (error || !data) throw new Error("Event konnte nicht erstellt werden.");
        return {...data, date: new Date(data.date)};
    },
    addEvents: async (eventsData: any[]): Promise<Event[]> => {
        const eventsToInsert = eventsData.map(e => ({
            title: e.title,
            location: e.location || "Hundeplatz Ascha", // Default location
            date: e.date.toISOString(),
            total_capacity: e.totalCapacity,
            category: e.category,
            booked_capacity: 0
        }));

        const { data, error } = await supabase.from('events').insert(eventsToInsert).select();
        if (error || !data) throw new Error("Events konnten nicht erstellt werden. " + error?.message);

        return data.map(e => ({...e, date: new Date(e.date)}));
    },
    updateEvent: async (eventId: string, updatedEventData: Partial<Omit<Event, 'id' | 'date' | 'total_capacity' | 'booked_capacity'>> & { date?: Date; totalCapacity?: number }): Promise<Event> => {
        // 1. Teilnehmer und deren Booking-IDs vor der Aktualisierung abrufen
        const { data: eventWithBookings, error: fetchError } = await supabase
            .from('events')
            .select('*, bookings_events(bookings(id, customers(*)))')
            .eq('id', eventId)
            .single();

        if (fetchError) {
            throw new Error("Fehler beim Abrufen der Event-Teilnehmer.");
        }
        
        const participants = eventWithBookings?.bookings_events
            .map(be => ({
                customer: be.bookings?.customers,
                bookingId: be.bookings?.id,
            }))
            .filter(p => p.customer && p.bookingId) ?? [];
        
        // 2. Event aktualisieren
        const payload: any = { ...updatedEventData };
        if (updatedEventData.date) payload.date = updatedEventData.date.toISOString();
        if (updatedEventData.totalCapacity) payload.total_capacity = updatedEventData.totalCapacity;
        delete payload.totalCapacity; // camelCase-Version entfernen

        const { data, error } = await supabase.from('events').update(payload).eq('id', eventId).select().single();
        if (error) throw new Error("Event konnte nicht aktualisiert werden.");
        
        const updatedEventResult = {...data, date: new Date(data.date)};

        // 3. Benachrichtigungen senden, wenn Teilnehmer vorhanden sind
        if (participants.length > 0) {
            try {
                await supabase.functions.invoke('send-update-notification', {
                    body: {
                        participants: participants,
                        event: {
                            title: updatedEventResult.title,
                            date: new Date(updatedEventResult.date).toLocaleString('de-DE', { dateStyle: 'full', timeStyle: 'short' }) + ' Uhr',
                            location: updatedEventResult.location,
                            category: updatedEventResult.category
                        }
                    }
                });
            } catch (invokeError) {
                // Fehler loggen, aber den Vorgang nicht abbrechen.
                // Die Event-Aktualisierung ist wichtiger als die Benachrichtigung.
                console.warn("Benachrichtigungs-E-Mail über Event-Änderung konnte nicht gesendet werden:", invokeError);
            }
        }
        
        return updatedEventResult;
    },
    deleteEvent: async (eventId: string): Promise<void> => {
        // Zuerst prüfen, ob Buchungen für dieses Event existieren
        const { count, error: countError } = await supabase
            .from('bookings_events')
            .select('*', { count: 'exact', head: true })
            .eq('event_id', eventId);

        if (countError) {
            throw new Error("Fehler beim Prüfen der Event-Buchungen.");
        }
        if (count > 0) {
            throw new Error(`Dieses Event kann nicht gelöscht werden, da bereits ${count} Buchung(en) dafür existieren.`);
        }
        
        // Wenn keine Buchungen vorhanden sind, das Event löschen
        const { error: deleteError } = await supabase.from('events').delete().eq('id', eventId);
        if (deleteError) {
            throw new Error("Event konnte nicht gelöscht werden.");
        }
    },
    cleanupOldEvents: async (): Promise<{ deletedCount: number }> => {
        const { data, error } = await supabase.functions.invoke('cleanup-old-events');
        
        if (error) {
            console.error("Error invoking cleanup function:", error);
            const detailedMessage = error.message || "Unbekannter Fehler.";
            throw new Error(`Fehler beim Aufräumen der Events: ${detailedMessage}`);
        }
        
        // Prüfe auch auf einen anwendungsseitigen Fehler, der von der Funktion zurückgegeben wird
        if (data && data.success === false) {
             console.error("Cleanup function returned a failure status:", data.details);
             throw new Error(`Die Aufräumfunktion hat einen Fehler gemeldet: ${data.details || 'Keine Details.'}`);
        }
        
        return data;
    },
};

// --- HELPER FUNKTIONEN ---
const formatDate = (date: Date) => new Intl.DateTimeFormat('de-DE', { weekday: 'short', day: '2-digit', month: 'short' }).format(date);
const formatTime = (date: Date) => new Intl.DateTimeFormat('de-DE', { hour: '2-digit', minute: '2-digit' }).format(date) + ' Uhr';
const formatMonthYear = (date: Date) => new Intl.DateTimeFormat('de-DE', { month: 'long', year: 'numeric' }).format(date);
const getWeekNumber = (d: Date): number => {
    d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
    d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil((((d.getTime() - yearStart.getTime()) / 86400000) + 1) / 7);
    return weekNo;
}
const toInputDateString = (date: Date): string => {
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    return `${year}-${month}-${day}`;
};
const toInputTimeString = (date: Date): string => {
    const hours = date.getHours().toString().padStart(2, '0');
    const minutes = date.getMinutes().toString().padStart(2, '0');
    return `${hours}:${minutes}`;
};


// --- KOMPONENTEN ---

const EventLegend = () => {
    return html`
        <div class="event-legend">
            <h4>Legende</h4>
            <ul class="legend-list">
                ${Object.entries(EVENT_CATEGORIES).map(([color, details]) => {
                    const categoryClass = `event-category-${color.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
                    // Use the first title as the representative name for the legend
                    const representativeTitle = details.titles[0];
                    return html`
                        <li class="legend-item" key=${color}>
                            <span class=${`legend-color-swatch ${categoryClass}`}></span>
                            <span>${representativeTitle}</span>
                        </li>
                    `;
                })}
            </ul>
        </div>
    `;
};

const ForgotPasswordModal = ({ onClose }) => {
    const [email, setEmail] = useState('');
    const [message, setMessage] = useState('');
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        setMessage('');
        setLoading(true);

        try {
            const { error: invokeError } = await supabase.functions.invoke('resend-booking-info', {
                body: { 
                    email: email.trim().toLowerCase()
                }
            });

            if (invokeError) {
                throw new Error("Ein Fehler ist aufgetreten. Bitte versuche es später erneut.");
            }
            
            setMessage("Anfrage erhalten. Wenn für diese E-Mail-Adresse eine Buchung existiert, haben wir dir eine E-Mail mit den Details gesendet.");

        } catch (err) {
            setError(err.message);
        } finally {
            setLoading(false);
        }
    };
    
    return html`
        <div class="modal-overlay" onClick=${onClose}>
            <div class="modal-content" onClick=${e => e.stopPropagation()}>
                <form onSubmit=${handleSubmit}>
                    <div class="modal-header">
                        <h2>Buchungsnummer anfordern</h2>
                        <button type="button" class="modal-close-btn" onClick=${onClose} aria-label="Schließen">×</button>
                    </div>
                    <div class="modal-body">
                        ${!message ? html`
                            <p>Gib die E-Mail-Adresse ein, die du bei der Buchung verwendet hast. Wir senden dir dann deine Buchungsnummer(n) zu.</p>
                            <div class="form-group">
                                <label for="recovery-email">E-Mail</label>
                                <input type="email" id="recovery-email" name="email" value=${email} onInput=${e => setEmail(e.target.value)} required autocomplete="email" />
                            </div>
                        ` : ''}
                        
                        ${error && html`<p class="error-message">${error}</p>`}
                        ${message && html`<p class="success-message">${message}</p>`}
                    </div>
                    <div class="modal-footer">
                         ${!message ? html`
                            <button type="button" class="btn btn-secondary" onClick=${onClose} disabled=${loading}>Abbrechen</button>
                            <button type="submit" class="btn btn-primary" disabled=${loading}>${loading ? 'Sendet...' : 'Senden'}</button>
                         ` : html `
                            <button type="button" class="btn btn-primary" onClick=${onClose}>Zurück zum Portal</button>
                         `}
                    </div>
                </form>
            </div>
        </div>
    `;
};


const EventItem = ({ event, onSelect, isSelected, isLocked }) => {
    const isFull = event.booked_capacity >= event.total_capacity;
    const remaining = event.total_capacity - event.booked_capacity;
    const isDisabled = isFull || isLocked;
    const categoryClass = `event-category-${event.category.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;

    return html`
        <li class=${`event-item ${isDisabled ? 'disabled' : ''} ${categoryClass}`}>
             ${!isFull && !isLocked && html`<input 
                type="checkbox" 
                id=${event.id}
                checked=${isSelected}
                onChange=${() => onSelect(event.id)}
                disabled=${isDisabled}
                aria-label=${`Event ${event.title} auswählen`}
            />`}
            <label for=${isFull || isLocked ? null : event.id} class="event-details">
                <span>${formatDate(event.date)} – ${formatTime(event.date)} – ${event.title} – ${event.location}</span>
            </label>
            <div class="event-capacity ${isFull ? 'capacity-full' : ''}">
                ${isLocked ? 'Vergangen' : isFull ? 'Leider Ausgebucht' : `${remaining} ${remaining === 1 ? 'Platz' : 'Plätze'} noch frei`}
            </div>
        </li>
    `;
};

const BookingPanel = ({ selectedEvents, customer, onCustomerChange, onSubmit, error, agreedAGB, onAgreedAGBChange, agreedPrivacy, onAgreedPrivacyChange }) => {
    if (selectedEvents.length === 0) {
        return html`
            <div class="booking-summary">
                <h3>Deine Auswahl</h3>
                <p class="empty-state">Wähle ein oder mehrere Events aus, um mit der Anmeldung zu beginnen.</p>
            </div>
        `;
    }

    const handleInput = (e) => {
        onCustomerChange({ ...customer, [e.target.name]: e.target.value });
    };
    
    const showSubmitButton =
        customer.name.trim() !== '' &&
        customer.dog_name.trim() !== '' &&
        customer.email.trim() !== '' &&
        customer.phone.trim() !== '' &&
        agreedAGB &&
        agreedPrivacy;

    return html`
        <div class="booking-panel">
            <div class="booking-form-container">
                 <form onSubmit=${onSubmit}>
                    <h3>Deine Anmeldung</h3>
                    
                    <ul class="selected-event-list">
                        ${selectedEvents.map(event => {
                            const categoryClass = `event-category-${event.category.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
                            return html`
                                <li key=${event.id} class=${`selected-event-item ${categoryClass}`}>
                                    <span>${event.title}</span>
                                    <span class="selected-event-time">${formatDate(event.date)}</span>
                                </li>
                            `
                        })}
                    </ul>

                    <p class="legal-notice">Hiermit melde ich mich rechtsverbindlich für die von mir ausgewählten Unterrichts-Stunden an. *</p>
                    <div class="form-group">
                        <label for="name">Name *</label>
                        <input type="text" id="name" name="name" value=${customer.name} onInput=${handleInput} required />
                    </div>
                    <div class="form-group">
                        <label for="dogName">Name des Hundes *</label>
                        <input type="text" id="dogName" name="dog_name" value=${customer.dog_name} onInput=${handleInput} required />
                    </div>
                     <div class="form-group">
                        <label for="email">E-Mail *</label>
                        <input type="email" id="email" name="email" value=${customer.email} onInput=${handleInput} required />
                    </div>
                    <div class="form-group">
                        <label for="phone">Telefon *</label>
                        <input type="tel" id="phone" name="phone" value=${customer.phone} onInput=${handleInput} required />
                    </div>
                    
                    <div class="form-group-checkbox">
                        <input type="checkbox" id="agb" name="agb" checked=${agreedAGB} onChange=${e => onAgreedAGBChange(e.target.checked)} required />
                        <label for="agb">Ich habe die <a href="https://drive.google.com/file/d/19fR6ruOHCrSdr3QawbLiis47rUKNVzM9/view?usp=sharing" target="_blank" rel="noopener noreferrer">AGB</a> gelesen und akzeptiere sie.</label>
                    </div>
                    <div class="form-group-checkbox">
                        <input type="checkbox" id="privacy" name="privacy" checked=${agreedPrivacy} onChange=${e => onAgreedPrivacyChange(e.target.checked)} required />
                        <label for="privacy">Ich habe die <a href="/datenschutz" target="_blank" rel="noopener noreferrer">Datenschutzerklärung</a> gelesen und akzeptiere sie.</label>
                    </div>

                    ${error && html`<p class="error-message">${error}</p>`}
                    
                    ${showSubmitButton ? html`
                        <button type="submit" class="btn btn-primary">
                          Rechtsverbindlich anmelden
                        </button>
                    ` : html`
                        <p class="form-hint">Bitte fülle alle Felder aus und akzeptiere die Bedingungen, um die Anmeldung abzuschließen.</p>
                    `}
                 </form>
            </div>
        </div>
    `;
}

const SuccessModal = ({ bookingDetails, onClose }) => {
    if (!bookingDetails) return null;

    return html`
        <div class="modal-overlay" onClick=${onClose}>
            <div class="modal-content" onClick=${e => e.stopPropagation()}>
                <div class="modal-header">
                    <h2>Buchung erfolgreich!</h2>
                    <button class="modal-close-btn" onClick=${onClose} aria-label="Schließen">×</button>
                </div>
                <div class="modal-body">
                    <p>Vielen Dank, ${bookingDetails.customerName}!</p>
                    <p>Deine Anmeldung war erfolgreich. Wir haben dir eine Bestätigung per E-Mail gesendet.</p>
                    <p class="booking-id">Deine Buchungsnummer lautet: <strong>${bookingDetails.bookingId}</strong></p>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-primary" onClick=${onClose}>Schließen</button>
                </div>
            </div>
        </div>
    `;
};

const EmailExistsModal = ({ email, onClose, onGoToManage, onForgotPassword }) => {
    return html`
        <div class="modal-overlay" onClick=${onClose}>
            <div class="modal-content" onClick=${e => e.stopPropagation()}>
                <div class="modal-header">
                    <h2>E-Mail-Adresse bereits registriert</h2>
                    <button type="button" class="modal-close-btn" onClick=${onClose} aria-label="Schließen">×</button>
                </div>
                <div class="modal-body">
                    <p>Für die E-Mail-Adresse <strong>${email}</strong> existiert bereits eine Buchung. Du kannst keine neue Anmeldung erstellen.</p>
                    <p>Möchtest du deine bestehende Buchung verwalten oder deine Buchungsnummer anfordern?</p>
                </div>
                <div class="modal-footer">
                     <button type="button" class="btn btn-secondary" onClick=${onForgotPassword}>Buchungsnummer vergessen?</button>
                     <button type="button" class="btn btn-primary" onClick=${onGoToManage}>Zur Buchungsverwaltung</button>
                </div>
            </div>
        </div>
    `;
};


const EventFormModal = ({ event, onSave, onClose }) => {
    const [formData, setFormData] = useState({
        title: '',
        location: '',
        date: '',
        time: '',
        totalCapacity: 6,
        category: Object.keys(EVENT_CATEGORIES)[0],
        trainer: '',
    });

    useEffect(() => {
        if (event) {
            setFormData({
                title: event.title,
                location: event.location,
                date: toInputDateString(event.date),
                time: toInputTimeString(event.date),
                totalCapacity: event.total_capacity,
                category: event.category,
                trainer: event.trainer || '',
            });
        } else {
             const defaultDate = new Date();
             defaultDate.setHours(10, 0, 0, 0);
             setFormData({
                title: '',
                location: '',
                date: toInputDateString(defaultDate),
                time: toInputTimeString(defaultDate),
                totalCapacity: 6,
                category: Object.keys(EVENT_CATEGORIES)[0],
                trainer: '',
            });
        }
    }, [event]);

    const handleChange = (e) => {
        setFormData({ ...formData, [e.target.name]: e.target.value });
    };

    const handleSubmit = (e) => {
        e.preventDefault();
        const combinedDate = new Date(`${formData.date}T${formData.time}`);
        const eventData = {
            title: formData.title,
            location: formData.location,
            date: combinedDate,
            totalCapacity: Number(formData.totalCapacity),
            category: formData.category,
            trainer: formData.trainer || null,
        };
        onSave(eventData);
    };
    
    return html`
        <div class="modal-overlay" onClick=${onClose}>
            <div class="modal-content" onClick=${e => e.stopPropagation()}>
                <form onSubmit=${handleSubmit}>
                    <div class="modal-header">
                        <h2>${event && event.id ? 'Event bearbeiten' : 'Neues Event erstellen'}</h2>
                        <button type="button" class="modal-close-btn" onClick=${onClose} aria-label="Schließen">×</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label for="title">Titel</label>
                            <input type="text" id="title" name="title" value=${formData.title} onInput=${handleChange} required />
                        </div>
                         <div class="form-group">
                            <label for="location">Treffpunkt</label>
                            <input type="text" id="location" name="location" value=${formData.location} onInput=${handleChange} placeholder="Standard: Hundeplatz Ascha" />
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label for="date">Datum</label>
                                <input type="date" id="date" name="date" value=${formData.date} onInput=${handleChange} required />
                            </div>
                            <div class="form-group">
                                <label for="time">Uhrzeit</label>
                                <input type="time" id="time" name="time" value=${formData.time} onInput=${handleChange} required />
                            </div>
                        </div>
                         <div class="form-row">
                            <div class="form-group">
                                <label for="totalCapacity">Plätze</label>
                                <input type="number" id="totalCapacity" name="totalCapacity" min="1" value=${formData.totalCapacity} onInput=${handleChange} required />
                            </div>
                            <div class="form-group">
                                <label for="category">Kategorie</label>
                                <select id="category" name="category" value=${formData.category} onChange=${handleChange}>
                                    ${Object.keys(EVENT_CATEGORIES).map(cat => html`<option value=${cat}>${cat}</option>`)}
                                </select>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="trainer">Trainer</label>
                            <select id="trainer" name="trainer" value=${formData.trainer} onChange=${handleChange}>
                                <option value="">Kein Trainer</option>
                                ${TRAINERS.map(t => html`<option key=${t} value=${t}>${t}</option>`)}
                            </select>
                        </div>
                    </div>
                    <div class="modal-footer">
                         <button type="button" class="btn btn-secondary" onClick=${onClose}>Abbrechen</button>
                         <button type="submit" class="btn btn-primary">Speichern</button>
                    </div>
                </form>
            </div>
        </div>
    `;
};

const ConfirmDeleteModal = ({ onConfirm, onClose, error, loading }) => {
    return html`
        <div class="modal-overlay" onClick=${onClose}>
            <div class="modal-content" onClick=${e => e.stopPropagation()}>
                <div class="modal-header">
                    <h2>Löschen bestätigen</h2>
                    <button type="button" class="modal-close-btn" onClick=${onClose} aria-label="Schließen">×</button>
                </div>
                <div class="modal-body">
                    <p>Bist du sicher, dass du dieses Event endgültig löschen möchtest?</p>
                    <p><strong>Diese Aktion kann nicht rückgängig gemacht werden.</strong></p>
                    ${error && html`<p class="error-message">${error}</p>`}
                </div>
                <div class="modal-footer">
                     <button type="button" class="btn btn-secondary" onClick=${onClose} disabled=${loading}>Abbrechen</button>
                     <button 
                        type="button" 
                        class="btn btn-danger" 
                        onClick=${onConfirm}
                        disabled=${loading}
                     >
                        ${loading ? 'Lösche...' : 'Ja, endgültig löschen'}
                     </button>
                </div>
            </div>
        </div>
    `;
};

const BookingOverview = () => {
    const [eventsWithBookings, setEventsWithBookings] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState('');

    useEffect(() => {
        const loadBookings = async () => {
            setLoading(true);
            setError('');
            try {
                // Fetch future events and their related bookings and customers
                const { data, error: fetchError } = await supabase
                    .from('events')
                    .select('*, bookings_events(bookings(*, customers(*)))')
                    .gte('date', new Date().toISOString())
                    .order('date', { ascending: true });

                if (fetchError) throw fetchError;

                setEventsWithBookings(data);
            } catch (err) {
                setError('Fehler beim Laden der Buchungsübersicht.');
                console.error(err);
            } finally {
                setLoading(false);
            }
        };

        loadBookings();
    }, []);

    if (loading) {
        return html`<div class="loading-state">Lade Buchungsübersicht...</div>`;
    }
    if (error) {
        return html`<p class="error-message">${error}</p>`;
    }
    if (eventsWithBookings.length === 0) {
        return html`<p class="empty-state">Keine zukünftigen Events mit Buchungen gefunden.</p>`;
    }

    return html`
        <div class="booking-overview-container">
            ${eventsWithBookings.map(event => {
                const participants = event.bookings_events
                    .map(be => be.bookings?.customers)
                    .filter(Boolean); // Filter out any null/undefined customers
                
                const categoryClass = `event-category-${event.category.toLowerCase()}`;

                return html`
                    <div class="overview-event-group" key=${event.id}>
                        <div class=${`overview-event-header ${categoryClass}`}>
                            <div class="overview-event-info">
                                <strong class="overview-event-title">${event.title}</strong>
                                <span class="overview-event-details">${formatDate(new Date(event.date))} - ${formatTime(new Date(event.date))}</span>
                                <span class="overview-event-details">Treffpunkt: ${event.location}</span>
                            </div>
                            <div class="overview-event-capacity">
                                ${event.booked_capacity} / ${event.total_capacity} Plätze
                            </div>
                        </div>

                        ${participants.length > 0 ? html`
                            <ul class="participant-list">
                                ${participants.map(customer => html`
                                    <li key=${customer.id}>
                                        <div class="participant-info">
                                            <strong>${customer.name}</strong> (Hund: ${customer.dog_name})
                                        </div>
                                        <div class="participant-contact">
                                            <span>${customer.email}</span>
                                            <span>${customer.phone}</span>
                                        </div>
                                    </li>
                                `)}
                            </ul>
                        ` : html`
                            <p class="no-participants-message">Für dieses Event gibt es noch keine Anmeldungen.</p>
                        `}
                    </div>
                `;
            })}
        </div>
    `;
};

const CsvImportModal = ({ onImport, onClose }) => {
    const [file, setFile] = useState(null);
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);
    const [successMessage, setSuccessMessage] = useState('');
    const fileInputRef = useRef(null);

    const handleFileChange = (e) => {
        setFile(e.target.files[0]);
        setError('');
        setSuccessMessage('');
    };

    const handleImportClick = async () => {
        if (!file) {
            setError('Bitte wähle eine CSV-Datei aus.');
            return;
        }
        setLoading(true);
        setError('');
        setSuccessMessage('');

        const reader = new FileReader();
        reader.onload = async (e) => {
            const text = e.target.result;
            try {
                const parsedEvents = parseCsv(text);
                if (parsedEvents.length === 0) {
                    throw new Error("Die CSV-Datei ist leer oder enthält keine validen Datenzeilen.");
                }
                await onImport(parsedEvents);
                setSuccessMessage(`${parsedEvents.length} Events erfolgreich importiert!`);
                setFile(null);
                if(fileInputRef.current) fileInputRef.current.value = "";
            } catch (err) {
                setError(err.message);
            } finally {
                setLoading(false);
            }
        };
        reader.onerror = () => {
             setError("Fehler beim Lesen der Datei.");
             setLoading(false);
        };
        reader.readAsText(file);
    };

    const parseCsv = (csvText) => {
        const lines = csvText.trim().split(/\r?\n/).filter(line => line.trim());
        if (lines.length < 2) {
            throw new Error("CSV-Datei muss eine Kopfzeile und mindestens eine Datenzeile enthalten.");
        }

        const header = lines.shift().trim().toLowerCase();
        const expectedHeader = "datum,uhrzeit,titel,treffpunkt,plätze,kategorie";
        if (header !== expectedHeader) {
            throw new Error(`Falsche Kopfzeile. Erwartet: "datum,uhrzeit,titel,treffpunkt,plätze,kategorie"`);
        }
        
        const events = [];
        const errors = [];
        
        lines.forEach((line, index) => {
            const values = line.split(',');
            if (values.length !== 6) {
                errors.push(`Zeile ${index + 2}: Falsche Spaltenanzahl. Erwartet 6, gefunden ${values.length}.`);
                return;
            }
            
            const [dateStr, timeStr, title, location, capacityStr, category] = values.map(v => v.trim());

            if (!dateStr || !timeStr || !title || !capacityStr || !category) {
                 errors.push(`Zeile ${index + 2}: Ein oder mehrere Felder sind leer. Alle Felder außer Treffpunkt sind erforderlich.`);
                 return;
            }

            const combinedDate = new Date(`${dateStr}T${timeStr}`);
            if (isNaN(combinedDate.getTime())) {
                errors.push(`Zeile ${index + 2}: Ungültiges Datum/Uhrzeit-Format. Bitte JJJJ-MM-TT und HH:MM verwenden.`);
                return;
            }

            const totalCapacity = parseInt(capacityStr, 10);
            if (isNaN(totalCapacity) || totalCapacity < 1) {
                errors.push(`Zeile ${index + 2}: "Plätze" muss eine Zahl größer 0 sein.`);
                return;
            }

            if (!Object.keys(EVENT_CATEGORIES).includes(category)) {
                 errors.push(`Zeile ${index + 2}: Unbekannte Kategorie "${category}". Gültige Kategorien sind: ${Object.keys(EVENT_CATEGORIES).join(', ')}`);
                 return;
            }
            
            events.push({
                date: combinedDate,
                title,
                location: location || "Hundeplatz Ascha",
                totalCapacity,
                category
            });
        });
        
        if (errors.length > 0) {
            throw new Error("Fehler in der CSV-Datei:\n" + errors.join('\n'));
        }
        
        return events;
    };
    
    return html`
        <div class="modal-overlay" onClick=${onClose}>
            <div class="modal-content" onClick=${e => e.stopPropagation()}>
                <div class="modal-header">
                    <h2>Events per CSV importieren</h2>
                    <button type="button" class="modal-close-btn" onClick=${onClose} aria-label="Schließen">×</button>
                </div>
                <div class="modal-body">
                    <p>Lade eine CSV-Datei hoch, um mehrere Events auf einmal zu erstellen.</p>
                    <div class="csv-instructions">
                        <strong>Anforderungen:</strong>
                        <ul>
                            <li>Die Datei muss im CSV-Format sein (komma-getrennt).</li>
                            <li>Die erste Zeile muss die exakte Kopfzeile sein: <code>datum,uhrzeit,titel,treffpunkt,plätze,kategorie</code></li>
                            <li>Datumsformat: <code>JJJJ-MM-TT</code></li>
                            <li>Uhrzeitformat: <code>HH:MM</code> (24-Stunden)</li>
                        </ul>
                        <strong>Beispiel:</strong>
                        <pre><code>datum,uhrzeit,titel,treffpunkt,plätze,kategorie\n2025-10-28,16:00,Welpenstunde,Welpenwiese,8,Orchid\n2025-10-29,18:30,L2 - Grundlagen,,6,LimeGreen</code></pre>
                        <p><small>Wenn der Treffpunkt leer gelassen wird, wird "Hundeplatz Ascha" als Standard verwendet.</small></p>
                    </div>

                    <div class="form-group">
                        <label for="csv-file">CSV-Datei auswählen</label>
                        <input type="file" id="csv-file" name="csv-file" accept=".csv" onChange=${handleFileChange} ref=${fileInputRef} />
                    </div>

                    ${error && html`<p class="error-message" style=${{whiteSpace: 'pre-wrap'}}>${error}</p>`}
                    ${successMessage && html`<p class="success-message">${successMessage}</p>`}
                </div>
                <div class="modal-footer">
                     <button type="button" class="btn btn-secondary" onClick=${onClose} disabled=${loading}>Schließen</button>
                     <button type="button" class="btn btn-primary" onClick=${handleImportClick} disabled=${loading || !file}>
                        ${loading ? 'Importiert...' : 'Importieren'}
                     </button>
                </div>
            </div>
        </div>
    `;
};


const AdminPanel = () => {
    const [events, setEvents] = useState([]);
    const [loading, setLoading] = useState(true);
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [isCsvModalOpen, setIsCsvModalOpen] = useState(false);
    const [editingEvent, setEditingEvent] = useState(null);
    const [deletingEventId, setDeletingEventId] = useState(null);
    const [deleteError, setDeleteError] = useState('');
    const [deleteLoading, setDeleteLoading] = useState(false);
    const [activeTab, setActiveTab] = useState('overview'); // 'overview' or 'events'
    const [cleanupLoading, setCleanupLoading] = useState(false);
    const [cleanupMessage, setCleanupMessage] = useState({ text: '', type: '' });
    const [isConfirmingCleanup, setIsConfirmingCleanup] = useState(false);

    const loadEvents = async () => {
        setLoading(true);
        const eventsFromApi = await api.getEvents();
        const now = new Date();
        const futureEvents = eventsFromApi.filter(e => new Date(e.date) >= now);
        setEvents(futureEvents);
        setLoading(false);
    };

    useEffect(() => {
        if (activeTab === 'events') {
            loadEvents();
        }
    }, [activeTab]);

    const handleAdd = () => {
        setEditingEvent(null);
        setIsModalOpen(true);
    };

    const handleEdit = (event) => {
        setEditingEvent(event);
        setIsModalOpen(true);
    };

    const handleCopy = (eventToCopy) => {
        const newDate = new Date(eventToCopy.date);
        newDate.setDate(newDate.getDate() + 7); // Setzt das Datum auf eine Woche später
        setEditingEvent({ ...eventToCopy, date: newDate, id: null });
        setIsModalOpen(true);
    };

    const handleStartDelete = (eventId) => {
        setDeleteError('');
        setDeletingEventId(eventId);
    };

    const handleCancelDelete = () => {
        setDeletingEventId(null);
    };

    const handleConfirmDelete = async () => {
        if (!deletingEventId) return;
        setDeleteLoading(true);
        setDeleteError('');
        try {
            await api.deleteEvent(deletingEventId);
            setDeletingEventId(null);
            loadEvents();
        } catch (err) {
            setDeleteError(err.message);
        } finally {
            setDeleteLoading(false);
        }
    };
    
    const handleStartCleanup = () => {
        setCleanupMessage({ text: '', type: '' });
        setIsConfirmingCleanup(true);
    };
    
    const handleConfirmCleanup = async () => {
        setIsConfirmingCleanup(false);
        setCleanupLoading(true);
        try {
            const result = await api.cleanupOldEvents();
            setCleanupMessage({ 
                text: `${result.deletedCount ?? 0} vergangene(s) Event(s) wurde(n) erfolgreich entfernt.`,
                type: 'success'
            });
        } catch (err) {
            setCleanupMessage({ text: `Fehler: ${err.message}`, type: 'error' });
        } finally {
            setCleanupLoading(false);
        }
    };

    const handleSave = async (eventData) => {
        const finalEventData = { ...eventData };

        // Wenn kein Treffpunkt angegeben wurde oder er leer ist, setze den Standardwert.
        if (!finalEventData.location || finalEventData.location.trim() === '') {
            finalEventData.location = "Hundeplatz Ascha";
        }

        if (editingEvent && editingEvent.id) {
            await api.updateEvent(editingEvent.id, finalEventData);
        } else {
            await api.addEvent(finalEventData);
        }
        setIsModalOpen(false);
        setEditingEvent(null);
        loadEvents();
    };
    
    const handleCsvImport = async (eventsToImport) => {
        // Die Funktion wird an das Modal übergeben. Fehlerbehandlung findet im Modal statt.
        // Bei Erfolg wird das Modal geschlossen und die Eventliste neu geladen.
        await api.addEvents(eventsToImport);
        setIsCsvModalOpen(false);
        loadEvents();
    };

    return html`
        <section class="admin-panel">
            <div class="admin-tabs">
                <button 
                    class=${`btn ${activeTab === 'overview' ? 'btn-primary' : 'btn-secondary'}`}
                    onClick=${() => setActiveTab('overview')}
                >Buchungsübersicht</button>
                <button 
                    class=${`btn ${activeTab === 'events' ? 'btn-primary' : 'btn-secondary'}`}
                    onClick=${() => setActiveTab('events')}
                >Event Verwaltung</button>
            </div>

            ${activeTab === 'overview' && html`<${BookingOverview} />`}

            ${activeTab === 'events' && html`
                <div class="event-management-view">
                    <div class="admin-header">
                        <h2>Event Verwaltung</h2>
                        <div class="admin-header-actions">
                            <button class="btn btn-primary" onClick=${handleAdd}>+ Neues Event</button>
                            <button class="btn btn-secondary" onClick=${() => setIsCsvModalOpen(true)}>CSV Import</button>
                            <div class="cleanup-container">
                                <div class="cleanup-control">
                                    ${cleanupLoading ? html`
                                        <div class="admin-cleanup-progress progress-indicator">
                                            <span class="progress-indicator-label">Lösche alte Events...</span>
                                            <div class="progress-bar-container">
                                                <div class="progress-bar"></div>
                                            </div>
                                        </div>
                                    ` : isConfirmingCleanup ? html`
                                        <div class="confirm-cleanup-actions">
                                            <span>Sicher?</span>
                                            <button class="btn btn-secondary btn-small" onClick=${() => setIsConfirmingCleanup(false)}>Abbrechen</button>
                                            <button class="btn btn-danger btn-small" onClick=${handleConfirmCleanup}>Ja, löschen</button>
                                        </div>
                                    ` : html`
                                        <button class="btn btn-danger" onClick=${handleStartCleanup}>
                                            Alte Events löschen
                                        </button>
                                    `}
                                </div>
                                ${cleanupMessage.text && html`
                                    <p class="cleanup-message ${cleanupMessage.type === 'error' ? 'error-message' : 'success-message'}">
                                        ${cleanupMessage.text}
                                    </p>
                                `}
                            </div>
                        </div>
                    </div>
                     ${loading ? html`<div class="loading-state">Lade Events...</div>` : html`
                        <ul class="admin-event-list">
                            ${events.map(event => html`
                                <li key=${event.id} class=${`admin-event-item event-category-${event.category.toLowerCase()}`}>
                                   <div class="admin-event-info">
                                        <strong>${event.title}</strong>
                                        <span>${formatDate(new Date(event.date))} - ${formatTime(new Date(event.date))}</span>
                                        <span>Treffpunkt: ${event.location}</span>
                                        <span>Plätze: ${event.booked_capacity} / ${event.total_capacity}</span>
                                   </div>
                                   ${event.trainer && html`
                                        <div class="admin-event-trainer">
                                            <span>Trainer: <strong>${event.trainer}</strong></span>
                                        </div>
                                   `}
                                   <div class="admin-event-actions">
                                       <button class="btn btn-secondary" onClick=${() => handleEdit(event)}>Bearbeiten</button>
                                       <button class="btn btn-secondary" onClick=${() => handleCopy(event)}>Kopieren</button>
                                       <button 
                                            class="btn btn-danger" 
                                            onClick=${() => handleStartDelete(event.id)}
                                            disabled=${event.booked_capacity > 0}
                                            title=${event.booked_capacity > 0 ? 'Event hat Buchungen und kann nicht gelöscht werden' : 'Event löschen'}
                                       >Löschen</button>
                                   </div>
                                </li>
                            `)}
                        </ul>
                    `}
                </div>
            `}
        </section>
        ${isModalOpen && html`
            <${EventFormModal} 
                event=${editingEvent}
                onSave=${handleSave}
                onClose=${() => setIsModalOpen(false)}
            />
        `}
        ${deletingEventId && html`
            <${ConfirmDeleteModal} 
                onConfirm=${handleConfirmDelete}
                onClose=${handleCancelDelete}
                error=${deleteError}
                loading=${deleteLoading}
            />
        `}
        ${isCsvModalOpen && html`
            <${CsvImportModal}
                onImport=${handleCsvImport}
                onClose=${() => setIsCsvModalOpen(false)}
            />
        `}
    `;
};

const BookingManagementPortal = ({ setView, initialBookingId }) => {
    const [bookingIdInput, setBookingIdInput] = useState(initialBookingId || '');
    const [booking, setBooking] = useState<Booking | null>(null);
    const [allEvents, setAllEvents] = useState<Event[]>([]);
    const [managedEventIds, setManagedEventIds] = useState<string[]>([]);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const [successMessage, setSuccessMessage] = useState('');
    const [hasChanges, setHasChanges] = useState(false);
    const [isForgotModalOpen, setIsForgotModalOpen] = useState(false);
    const [updateComplete, setUpdateComplete] = useState(false);

    const performLookup = async (idToLookup: string) => {
        if (!idToLookup) return;
        setError('');
        setSuccessMessage('');
        setIsLoading(true);
        setBooking(null);
        try {
            const foundBooking = await api.getBookingById(idToLookup.trim());
            if (foundBooking) {
                setBooking(foundBooking);
                setManagedEventIds(foundBooking.bookedEventIds);
            } else {
                setError('Buchung nicht gefunden. Bitte überprüfe die Buchungsnummer.');
            }
        } catch (err) {
            setError(err.message);
        } finally {
            setIsLoading(false);
        }
    };

    useEffect(() => {
        if (initialBookingId) {
            performLookup(initialBookingId);
        }
    }, [initialBookingId]);

    useEffect(() => {
        if (booking) {
            setIsLoading(true);
            api.getEvents().then(events => {
                setAllEvents(events.map(e => ({...e, date: new Date(e.date)})));
                setIsLoading(false);
            });
        }
    }, [booking]);

    useEffect(() => {
        if (booking) {
            setHasChanges(JSON.stringify(booking.bookedEventIds.sort()) !== JSON.stringify(managedEventIds.sort()));
        } else {
            setHasChanges(false);
        }
    }, [managedEventIds, booking]);

    const handleLookupSubmit = async (e) => {
        e.preventDefault();
        performLookup(bookingIdInput);
    };

    const handleSaveChanges = async () => {
        if (!booking) return;
        setError('');
        setSuccessMessage('');
        setIsLoading(true);
        try {
            const updatedBooking = await api.updateBooking(booking.bookingId, managedEventIds);
            setBooking(updatedBooking); // update local state with the saved data
            setManagedEventIds(updatedBooking.bookedEventIds);
            setUpdateComplete(true);

            // E-Mail-Versand für Update anstoßen
            try {
                const updatedEventsDetails = allEvents
                    .filter(event => updatedBooking.bookedEventIds.includes(event.id))
                    .map(e => ({
                        title: e.title,
                        date: new Date(e.date).toLocaleString('de-DE', { dateStyle: 'full', timeStyle: 'short' }) + ' Uhr',
                        location: e.location,
                        category: e.category
                    }));
                
                await supabase.functions.invoke('send-smtp-email', {
                    body: {
                        type: 'update-booking',
                        customerName: updatedBooking.customer.name,
                        customerEmail: updatedBooking.customer.email,
                        bookingId: updatedBooking.bookingId,
                        events: updatedEventsDetails
                    }
                });
            } catch (emailError) {
                console.warn("E-Mail-Funktion konnte nicht aufgerufen werden. Stelle sicher, dass die Supabase Edge Function 'send-smtp-email' deployed ist.", emailError);
            }

        } catch (err) {
            setError(err.message);
        } finally {
            setIsLoading(false);
        }
    };

    const handleEventToggle = (eventId: string) => {
        setManagedEventIds(prev =>
            prev.includes(eventId) ? prev.filter(id => id !== eventId) : [...prev, eventId]
        );
    };
    
    const handleReset = () => {
        setBooking(null);
        setBookingIdInput('');
        setUpdateComplete(false);
        setError('');
        setSuccessMessage('');
    }

    const { bookedEvents, availableEvents } = useMemo(() => {
        if (!booking) return { bookedEvents: [], availableEvents: [] };
        const now = new Date();
        const booked = allEvents
            .filter(e => managedEventIds.includes(e.id) && e.date >= now)
            .sort((a, b) => a.date.getTime() - b.date.getTime());

        const available = allEvents
            .filter(e => {
                if (managedEventIds.includes(e.id)) return false; // Already in selection
                if (e.date < now) return false; // In the past
                if (e.booked_capacity >= e.total_capacity) return false; // Full
                return true;
            })
            .sort((a, b) => a.date.getTime() - b.date.getTime());
        return { bookedEvents: booked, availableEvents: available };
    }, [allEvents, managedEventIds, booking]);

    if (updateComplete) {
        return html`
            <section class="manage-portal-success">
                <h2>Änderungen gespeichert!</h2>
                <p class="success-message">Deine Buchung wurde erfolgreich aktualisiert. Wir haben dir eine Bestätigungs-E-Mail gesendet.</p>
                <div class="manage-footer">
                    <button class="btn btn-secondary" onClick=${() => setView('booking')}>Zurück zur Eventliste</button>
                    <button class="btn btn-primary" onClick=${handleReset}>Andere Buchung verwalten</button>
                </div>
            </section>
        `;
    }

    if (!booking) {
        return html`
            <section class="booking-lookup-form">
                <form onSubmit=${handleLookupSubmit}>
                    <h2>Meine Buchungen verwalten</h2>
                    <p>Gib eine deiner Buchungsnummern ein, um deine Termine zu bearbeiten.</p>
                    <div class="form-group">
                        <label for="bookingId">Buchungsnummer</label>
                        <input type="text" id="bookingId" name="bookingId" value=${bookingIdInput} onInput=${e => setBookingIdInput(e.target.value)} required placeholder="z.B. Bello-12345" />
                    </div>
                    ${error && html`<p class="error-message">${error}</p>`}
                    <button type="submit" class="btn btn-primary" disabled=${isLoading}>
                        ${isLoading ? 'Sucht...' : 'Buchung suchen'}
                    </button>
                </form>
                 <button class="forgot-booking-id-btn" onClick=${() => setIsForgotModalOpen(true)}>
                    Buchungsnummer vergessen?
                </button>
            </section>
            ${isForgotModalOpen && html`<${ForgotPasswordModal} onClose=${() => setIsForgotModalOpen(false)} />`}
        `;
    }

    return html`
       <section class="manage-portal">
            <h2>Buchungsübersicht für ${booking.customer.name}</h2>
            <p>Buchungsnummer: <strong>${booking.bookingId}</strong></p>
            
            ${error && html`<p class="error-message">${error}</p>`}
            ${successMessage && html`<p class="success-message">${successMessage}</p>`}

            <div class="manage-container">
                <div class="manage-section">
                    <h3>Deine gebuchten Events</h3>
                    ${bookedEvents.length > 0 ? html`
                        <ul class="manage-event-list">
                            ${bookedEvents.map(event => {
                                const hoursUntil = (event.date.getTime() - new Date().getTime()) / (1000 * 60 * 60);
                                const canCancel = hoursUntil >= CANCELLATION_WINDOW_HOURS;
                                const categoryClass = `event-category-${event.category.toLowerCase()}`;
                                return html`
                                    <li key=${event.id} class=${`manage-event-item ${categoryClass}`}>
                                        <div class="manage-event-details">
                                            <strong>${event.title}</strong>
                                            <span>${formatDate(event.date)} - ${formatTime(event.date)}</span>
                                            ${!canCancel && html`<small class="cancel-warning">Stornierung nicht mehr möglich</small>`}
                                        </div>
                                        <button class="btn btn-danger" onClick=${() => handleEventToggle(event.id)} disabled=${!canCancel}>Stornieren</button>
                                    </li>
                                `;
                            })}
                        </ul>
                    ` : html`<p class="empty-state-small">Du hast aktuell keine Events gebucht.</p>`}
                </div>
                <div class="manage-section">
                    <h3>Verfügbare Events</h3>
                     ${availableEvents.length > 0 ? html`
                        <ul class="manage-event-list">
                            ${availableEvents.map(event => {
                                const categoryClass = `event-category-${event.category.toLowerCase()}`;
                                return html`
                                     <li key=${event.id} class=${`manage-event-item ${categoryClass}`}>
                                        <div class="manage-event-details">
                                            <strong>${event.title}</strong>
                                            <span>${formatDate(event.date)} - ${formatTime(event.date)}</span>
                                            <small>${event.total_capacity - event.booked_capacity} Plätze frei</small>
                                        </div>
                                        <button class="btn btn-success" onClick=${() => handleEventToggle(event.id)}>Buchen</button>
                                    </li>
                                `;
                            })}
                        </ul>
                    ` : html`<p class="empty-state-small">Aktuell sind keine weiteren Events verfügbar.</p>`}
                </div>
            </div>
            <div class="manage-footer">
                <button class="btn btn-secondary" onClick=${handleReset}>Andere Buchung suchen</button>
                <button class="btn btn-primary" onClick=${handleSaveChanges} disabled=${!hasChanges || isLoading}>
                    ${isLoading ? 'Speichert...' : 'Änderungen speichern'}
                </button>
            </div>
       </section>
    `;
};


const CustomerBookingView = ({ setView }) => {
    const [allEvents, setAllEvents] = useState<Event[]>([]);
    const [loading, setLoading] = useState(true);
    const [selectedEventIds, setSelectedEventIds] = useState<string[]>([]);
    const [customer, setCustomer] = useState<Omit<Customer, 'id'>>({ name: '', phone: '', dog_name: '', email: '' });
    const [bookingError, setBookingError] = useState('');
    const [agreedAGB, setAgreedAGB] = useState(false);
    const [agreedPrivacy, setAgreedPrivacy] = useState(false);
    const [bookingSuccess, setBookingSuccess] = useState(false);
    const [successfulBookingDetails, setSuccessfulBookingDetails] = useState(null);
    const [isEmailExistsModalOpen, setIsEmailExistsModalOpen] = useState(false);
    const [isForgotModalOpen, setIsForgotModalOpen] = useState(false);

    const loadInitialData = async () => {
        setLoading(true);
        try {
            const events = await api.getEvents();
            setAllEvents(events);
        } catch (error) {
            setBookingError("Fehler beim Laden der Events. Bitte versuche es später erneut.");
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        loadInitialData();
    }, []);

    const handleSelectEvent = (eventId: string) => {
        setSelectedEventIds(prev =>
            prev.includes(eventId) ? prev.filter(id => id !== eventId) : [...prev, eventId]
        );
    };
    
    const handleCloseModal = () => {
        setBookingSuccess(false);
        setSuccessfulBookingDetails(null);
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setBookingError('');
        try {
            const booking = await api.saveBooking(customer, selectedEventIds);
            setSuccessfulBookingDetails({ bookingId: booking.bookingId, customerName: customer.name });
            setBookingSuccess(true);
            
            // E-Mail-Versand anstoßen
            try {
                const bookedEventsDetails = allEvents
                    .filter(event => selectedEventIds.includes(event.id))
                    .map(e => ({
                        title: e.title,
                        date: new Date(e.date).toLocaleString('de-DE', { dateStyle: 'full', timeStyle: 'short' }) + ' Uhr',
                        location: e.location,
                        category: e.category
                    }));

                await supabase.functions.invoke('send-smtp-email', {
                    body: {
                        type: 'new-booking',
                        customerName: customer.name,
                        customerEmail: customer.email,
                        bookingId: booking.bookingId,
                        events: bookedEventsDetails
                    }
                });
            } catch (emailError) {
                console.warn("E-Mail-Funktion konnte nicht aufgerufen werden. Stelle sicher, dass die Supabase Edge Function 'send-smtp-email' deployed ist.", emailError);
            }

            // Immediately reload events to show updated capacity from the database trigger
            loadInitialData();

            // Reset state after successful booking
            setSelectedEventIds([]);
            setCustomer({ name: '', phone: '', dog_name: '', email: '' });
            setAgreedAGB(false);
            setAgreedPrivacy(false);

        } catch (err) {
            if (err.message.includes('Für diese E-Mail-Adresse existiert bereits eine Buchung')) {
                setIsEmailExistsModalOpen(true);
            } else {
                setBookingError(err.message);
            }
        }
    }
    
    const { eventsByWeek, selectedEvents } = useMemo(() => {
        const now = new Date();
        const futureEvents = allEvents
            .filter(event => event.date >= now)
            .sort((a, b) => a.date.getTime() - b.date.getTime());

        const groupedByWeek = futureEvents.reduce((acc, event) => {
            const week = getWeekNumber(event.date);
            const year = event.date.getFullYear();
            const key = `${year}-${String(week).padStart(2, '0')}`;

            if (!acc[key]) {
                acc[key] = { events: [] };
            }
            acc[key].events.push(event);
            return acc;
        }, {});

        const sortedKeys = Object.keys(groupedByWeek).sort();

        const eventsByWeek = sortedKeys.map(key => {
            const group = groupedByWeek[key];
            const firstEventDate = group.events[0].date;
            const weekNumber = getWeekNumber(firstEventDate);
            return {
                weekHeader: `${formatMonthYear(firstEventDate)} - Kalenderwoche ${weekNumber}`,
                events: group.events
            };
        });
        
        const selectedEvents = allEvents.filter(event => selectedEventIds.includes(event.id)).sort((a,b) => a.date.getTime() - b.date.getTime());
            
        return { eventsByWeek, selectedEvents };
    }, [allEvents, selectedEventIds]);

    if (loading) {
        return html`<div class="loading-state">Lade Eventtermine...</div>`;
    }
    
    const now = new Date();
    
    return html`
        <main class="main-container">
            <section class="events-section">
                <div class="events-container-box">
                    <div class="month-navigator">
                        <h2>Eventliste Hundeschule</h2>
                    </div>
                    <${EventLegend} />
                    <div class="event-list-container">
                        ${eventsByWeek.length > 0 ? eventsByWeek.map(weekGroup => html`
                            <div class="week-group" key=${weekGroup.weekHeader}>
                                <h3 class="week-header">${weekGroup.weekHeader}</h3>
                                <ul class="event-list">
                                    ${weekGroup.events.map(event => {
                                        const isPast = event.date < now;
                                        return html`
                                        <${EventItem} 
                                            key=${event.id}
                                            event=${event}
                                            onSelect=${handleSelectEvent}
                                            isSelected=${selectedEventIds.includes(event.id)}
                                            isLocked=${isPast}
                                        />
                                    `})}
                                </ul>
                            </div>
                        `) : html`
                            <p class="empty-state">Aktuell gibt es keine verfügbaren Events.</p>
                        `}
                    </div>
                </div>
            </section>
            
            <aside class="booking-section">
                <${BookingPanel} 
                    selectedEvents=${selectedEvents}
                    customer=${customer}
                    onCustomerChange=${setCustomer}
                    onSubmit=${handleSubmit}
                    error=${bookingError}
                    agreedAGB=${agreedAGB}
                    onAgreedAGBChange=${setAgreedAGB}
                    agreedPrivacy=${agreedPrivacy}
                    onAgreedPrivacyChange=${setAgreedPrivacy}
                />
            </aside>
        </main>
        ${bookingSuccess && html`
            <${SuccessModal} 
                bookingDetails=${successfulBookingDetails}
                onClose=${handleCloseModal}
            />
        `}
        ${isEmailExistsModalOpen && html`
            <${EmailExistsModal} 
                email=${customer.email}
                onClose=${() => setIsEmailExistsModalOpen(false)}
                onGoToManage=${() => {
                    setIsEmailExistsModalOpen(false);
                    setView('manage');
                }}
                onForgotPassword=${() => {
                    setIsEmailExistsModalOpen(false);
                    setIsForgotModalOpen(true);
                }}
            />
        `}
        ${isForgotModalOpen && html`
            <${ForgotPasswordModal} 
                onClose=${() => setIsForgotModalOpen(false)}
            />
        `}
    `;
};

const AdminLoginModal = ({ onClose }) => {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        setLoading(true);
        
        const { error: signInError } = await supabase.auth.signInWithPassword({
            email: email,
            password: password,
        });
        
        setLoading(false);

        if (signInError) {
            setError('Falsche E-Mail-Adresse oder Passwort.');
        } else {
            // Success is handled by the onAuthStateChange listener in the App component.
            onClose();
        }
    };

    return html`
        <div class="modal-overlay" onClick=${onClose}>
            <div class="modal-content" onClick=${e => e.stopPropagation()}>
                <form onSubmit=${handleSubmit}>
                    <div class="modal-header">
                        <h2>Admin Login</h2>
                        <button type="button" class="modal-close-btn" onClick=${onClose} aria-label="Schließen">×</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label for="admin-email">E-Mail</label>
                            <input type="email" id="admin-email" name="email" value=${email} onInput=${e => setEmail(e.target.value)} required autocomplete="email" />
                        </div>
                        <div class="form-group">
                            <label for="admin-password">Passwort</label>
                            <input type="password" id="admin-password" name="password" value=${password} onInput=${e => setPassword(e.target.value)} required autocomplete="current-password" />
                        </div>
                        ${error && html`<p class="error-message">${error}</p>`}
                    </div>
                    <div class="modal-footer">
                         <button type="button" class="btn btn-secondary" onClick=${onClose} disabled=${loading}>Abbrechen</button>
                         <button type="submit" class="btn btn-primary" disabled=${loading}>${loading ? 'Logge ein...' : 'Login'}</button>
                    </div>
                </form>
            </div>
        </div>
    `;
};


const App = () => {
    const [view, setView] = useState('booking');
    const [session, setSession] = useState<Session | null>(null);
    const [userRole, setUserRole] = useState<string | null>(null);
    const [isLoginModalOpen, setIsLoginModalOpen] = useState(false);
    const [initialBookingId, setInitialBookingId] = useState<string | null>(null);
    const [installPromptEvent, setInstallPromptEvent] = useState(null);

    useEffect(() => {
        // Service Worker Registration for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed: ', error);
                    });
            });
        }
        
        // --- PWA Installation Prompt Handling ---
        const handleBeforeInstallPrompt = (e) => {
            // Prevent the mini-infobar from appearing on mobile.
            e.preventDefault();
            // Stash the event so it can be triggered later.
            setInstallPromptEvent(e);
            console.log("'beforeinstallprompt' event was fired.");
        };

        const handleAppInstalled = () => {
            console.log('PWA was installed');
            // Hide the install button as it's no longer needed
            setInstallPromptEvent(null);
        };

        window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
        window.addEventListener('appinstalled', handleAppInstalled);

        
        // Handle URL parameters for direct linking
        const params = new URLSearchParams(window.location.search);
        const viewParam = params.get('view');
        const bookingIdParam = params.get('bookingId');
        if (viewParam === 'manage' && bookingIdParam) {
            setView('manage');
            setInitialBookingId(bookingIdParam);
        }

        // Fetch the initial session
        supabase.auth.getSession().then(({ data: { session } }) => {
            setSession(session);
            setUserRole(session?.user?.user_metadata?.role ?? null);
        });

        // Listen for changes in auth state (login, logout)
        const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
            setSession(session);
            // Get role from metadata. You need to set this in Supabase Auth > Users > User Management
            setUserRole(session?.user?.user_metadata?.role ?? null);
            if (session) { // If a session is established (login successful)
                setIsLoginModalOpen(false);
                setView('admin'); // Automatically switch to admin view on login
            }
        });

        // Cleanup subscription on component unmount
        return () => {
            subscription.unsubscribe();
            window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
            window.removeEventListener('appinstalled', handleAppInstalled);
        };
    }, []);


    const handleLogout = async () => {
        await supabase.auth.signOut();
        setUserRole(null);
        setView('booking');
    };

    const handleInstallClick = async () => {
        if (!installPromptEvent) {
            return;
        }
        // Show the native installation prompt
        installPromptEvent.prompt();
        // Wait for the user to respond to the prompt
        const { outcome } = await installPromptEvent.userChoice;
        console.log(`User response to the install prompt: ${outcome}`);
        // We've used the prompt, and can't use it again. Clear it.
        setInstallPromptEvent(null);
    };

    return html`
        <header class="booking-tool-header">
            <div class="header-content">
                <div 
                    class=${`logo-container ${installPromptEvent ? 'installable' : ''}`}
                    onClick=${installPromptEvent ? handleInstallClick : null}
                    title=${installPromptEvent ? 'App auf diesem Gerät installieren' : ''}
                >
                    <img src="https://hs-bw.com/wp-content/uploads/2025/10/Pfoten-Card-Icon.png" alt="Pfoten-Event Logo" class="header-logo" />
                    ${installPromptEvent && html`
                        <span class="install-prompt-text">App installieren</span>
                    `}
                </div>
                <div class="header-text">
                    <h1>Pfoten-Event</h1>
                    <p>Wähle deine Wunschtermine, verwalte deine Buchungen</p>
                </div>
            </div>
            <nav class="main-nav">
                <button class=${`btn ${view === 'booking' ? 'btn-primary' : 'btn-secondary'}`} onClick=${() => setView('booking')}>Buchungsansicht</button>
                <button class=${`btn ${view === 'manage' ? 'btn-primary' : 'btn-secondary'}`} onClick=${() => setView('manage')}>Meine Buchungen verwalten</button>
                ${session && html`
                    <button class=${`btn ${view === 'admin' ? 'btn-primary' : 'btn-secondary'}`} onClick=${() => setView('admin')}>Mitarbeiter-Panel</button>
                    <button class="btn btn-secondary" onClick=${handleLogout}>Logout</button>
                `}
            </nav>
        </header>

        <main>
            ${view === 'booking' && html`<${CustomerBookingView} setView=${setView} />`}
            ${view === 'manage' && html`<${BookingManagementPortal} setView=${setView} initialBookingId=${initialBookingId} />`}
            
            ${session && view === 'admin' && userRole === 'admin' && html`<${AdminPanel} />`}
            
            ${session && view === 'admin' && userRole === 'mitarbeiter' && html`
                <section class="admin-panel">
                    <div class="admin-header">
                        <h2>Buchungsübersicht</h2>
                    </div>
                    <${BookingOverview} />
                </section>
            `}
        </main>
        
        ${!session && html`
            <footer class="app-footer">
                <button class="admin-login-btn" onClick=${() => setIsLoginModalOpen(true)}>Mitarbeiter Login</button>
            </footer>
        `}

        ${isLoginModalOpen && html`
            <${AdminLoginModal} 
                onClose=${() => setIsLoginModalOpen(false)}
            />
        `}
    `;
};


render(html`<${App} />`, document.getElementById('app'));