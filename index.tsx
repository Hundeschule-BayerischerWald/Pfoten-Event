/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
*/
import { render, h } from 'preact';
import { useState, useEffect, useMemo } from 'preact/hooks';
import htm from 'htm';
import { createClient, Session } from 'supabase';

const html = htm.bind(h);

// --- SUPABASE KONFIGURATION ---
// BITTE ERSETZE DIESE WERTE MIT DEINEN EIGENEN SUPABASE PROJEKT-DATEN
// Du findest sie in deinem Supabase Dashboard unter Project Settings > API
const supabaseUrl = 'https://wjlroiymmpvwaapboahh.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndqbHJvaXltbXB2d2FhcGJvYWhoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk5NDExNDMsImV4cCI6MjA3NTUxNzE0M30.oRDURzRrudCmNAis4ZACxPsbWJwdxHt5Nw49phamZO4';
const supabase = createClient(supabaseUrl, supabaseKey);


// --- KONFIGURATION ---
const CANCELLATION_WINDOW_HOURS = 24; // Stornierungen/Änderungen nur bis 24h vor dem Event möglich

const EVENT_CATEGORIES = {
    "Orchid": { titles: ["Welpenstunde"], locations: ["Welpenwiese"] },
    "LimeGreen": { titles: ["L2 - Grundlagen"], locations: ["Der sichere Start"] },
    "SkyBlue": { titles: ["Tierische Eindrücke"], locations: ["Tierpark Straubing"] },
    "Peru": { titles: ["L4 - Treffpunkt"], locations: ["Bahnhof Mitterfels"] },
    "Gold": { titles: ["Trainerstunde"], locations: ["Nach Absprache"] },
    "White": { titles: ["Verbindlichkeit auf Distanz"], locations: ["Weites Feld"] },
    "DarkKhaki": { titles: ["Gelassenheitstraining"], locations: ["Stadtwald"] },
    "Tomato": { titles: ["Spezialkurs: Apportieren"], locations: ["Hundeschule Innenbereich"] }
};

// --- TYPEN & INTERFACES ---
interface Event {
    id: string;
    date: Date;
    title: string;
    location: string;
    total_capacity: number; // snake_case from db
    booked_capacity: number; // snake_case from db
    category: string;
}

interface Customer {
    id?: string; // Optional because it's generated by DB
    name: string;
    phone: string;
    dog_name: string; // snake_case from db
    email: string;
}

interface Booking {
    bookingId: string;
    customer: Customer;
    bookedEventIds: string[];
}


// --- API-SCHICHT (Supabase) ---
const api = {
    getEvents: async (): Promise<Event[]> => {
        const { data, error } = await supabase.from('events').select('*').order('date', { ascending: true });
        if (error) {
            console.error('Error fetching events:', error);
            throw error;
        }
        // Konvertiere Datum-Strings in Date-Objekte
        return data.map(e => ({...e, date: new Date(e.date)}));
    },
    saveBooking: async (customer: Omit<Customer, 'id'>, eventIds: string[]): Promise<Booking> => {
        // 1. Prüfe, ob Events noch verfügbar sind
        const { data: events, error: eventError } = await supabase.from('events').select('id, title, total_capacity, booked_capacity').in('id', eventIds);
        if (eventError) throw new Error("Fehler beim Prüfen der Events.");
        
        for (const eventId of eventIds) {
            const event = events.find(e => e.id === eventId);
            if (!event || event.booked_capacity >= event.total_capacity) {
                throw new Error(`Event "${event?.title || 'Unbekannt'}" ist leider ausgebucht.`);
            }
        }

        // 2. Prüfe, ob Kunde mit dieser E-Mail bereits existiert
        const { data: existingCustomer } = await supabase.from('customers').select('id').eq('email', customer.email.toLowerCase()).maybeSingle();
        if (existingCustomer) {
            throw new Error('Für diese E-Mail-Adresse existiert bereits eine Buchung. Bitte nutze die "Buchung verwalten"-Funktion.');
        }

        // 3. Erstelle neuen Kunden
        const { data: newCustomer, error: customerError } = await supabase.from('customers').insert({
            name: customer.name,
            phone: customer.phone,
            dog_name: customer.dog_name,
            email: customer.email.toLowerCase()
        }).select().single();

        if (customerError || !newCustomer) {
            throw new Error("Kunde konnte nicht erstellt werden.");
        }

        // 4. Erstelle neue Buchung
        const sanitizedDogName = customer.dog_name.trim().replace(/\s+/g, '-');
        const randomNumber = Math.floor(10000 + Math.random() * 90000);
        const newBookingId = `${sanitizedDogName}-${randomNumber}`;
        const { error: bookingError } = await supabase.from('bookings').insert({
            id: newBookingId,
            customer_id: newCustomer.id
        });

        if (bookingError) {
            // "Rollback" - lösche den eben erstellten Kunden
            await supabase.from('customers').delete().eq('id', newCustomer.id);
            throw new Error("Buchung konnte nicht erstellt werden.");
        }
        
        // 5. Verknüpfe Buchung mit Events
        const bookingEvents = eventIds.map(eventId => ({ booking_id: newBookingId, event_id: eventId }));
        const { error: bookingEventsError } = await supabase.from('bookings_events').insert(bookingEvents);

        if (bookingEventsError) {
             await supabase.from('customers').delete().eq('id', newCustomer.id); // Rollback
             await supabase.from('bookings').delete().eq('id', newBookingId); // Rollback
             throw new Error("Events konnten nicht zur Buchung hinzugefügt werden.");
        }
        
        // 6. Aktualisiere die `booked_capacity` der Events
        // Hinweis: Dies geschieht nacheinander und ist nicht atomar. Für eine robustere Lösung
        // wäre eine Postgres Function (RPC Call in Supabase) ideal.
        for (const eventId of eventIds) {
             const event = events.find(e => e.id === eventId);
             if (event) {
                await supabase.from('events')
                    .update({ booked_capacity: event.booked_capacity + 1 })
                    .eq('id', eventId);
             }
        }

        return {
            bookingId: newBookingId,
            customer: newCustomer,
            bookedEventIds: eventIds
        };
    },
    getBookingById: async (bookingId: string): Promise<Booking | null> => {
        const { data, error } = await supabase
            .from('bookings')
            .select(`
                id,
                customer:customers (*),
                events:bookings_events (event_id)
            `)
            .eq('id', bookingId)
            .single();

        if (error || !data) {
            if(error && error.code !== 'PGRST116') console.error('Error fetching booking:', error); // PGRST116: "exact one row" error
            return null;
        }
        
        // Transformiere die Daten in das benötigte Frontend-Format
        const booking: Booking = {
            bookingId: data.id,
            customer: {
                id: data.customer.id,
                name: data.customer.name,
                phone: data.customer.phone,
                dog_name: data.customer.dog_name,
                email: data.customer.email,
            },
            bookedEventIds: data.events.map((be: any) => be.event_id),
        };
        return booking;
    },
    updateBooking: async (bookingId: string, newEventIds: string[]): Promise<Booking> => {
        const originalBooking = await api.getBookingById(bookingId);
        if (!originalBooking) throw new Error("Buchung nicht gefunden.");

        const originalEventIds = originalBooking.bookedEventIds;
        const addedIds = newEventIds.filter(id => !originalEventIds.includes(id));
        const removedIds = originalEventIds.filter(id => !newEventIds.includes(id));
        const now = new Date();

        const allEvents = await api.getEvents();

        // Stornierungen prüfen
        for (const removedId of removedIds) {
            const event = allEvents.find(e => e.id === removedId);
            if (event) {
                const hoursUntilEvent = (new Date(event.date).getTime() - now.getTime()) / (1000 * 60 * 60);
                if (hoursUntilEvent < CANCELLATION_WINDOW_HOURS) {
                    throw new Error(`Stornierung für "${event.title}" nicht möglich, da der Kurs in weniger als 24 Stunden beginnt.`);
                }
            }
        }

        // Neue Buchungen prüfen
        for (const addedId of addedIds) {
            const event = allEvents.find(e => e.id === addedId);
            if (!event || event.booked_capacity >= event.total_capacity) {
                throw new Error(`Kurs "${event?.title}" ist leider ausgebucht.`);
            }
        }

        // Änderungen in der Datenbank durchführen
        if (removedIds.length > 0) {
            await supabase.from('bookings_events').delete().eq('booking_id', bookingId).in('event_id', removedIds);
            for (const removedId of removedIds) {
                const event = allEvents.find(e => e.id === removedId);
                if (event) {
                    await supabase.from('events')
                        .update({ booked_capacity: Math.max(0, event.booked_capacity - 1) })
                        .eq('id', removedId);
                }
            }
        }

        if (addedIds.length > 0) {
            await supabase.from('bookings_events').insert(addedIds.map(id => ({ booking_id: bookingId, event_id: id })));
             for (const addedId of addedIds) {
                const event = allEvents.find(e => e.id === addedId);
                if (event) {
                    await supabase.from('events')
                        .update({ booked_capacity: event.booked_capacity + 1 })
                        .eq('id', addedId);
                }
            }
        }
        
        return (await api.getBookingById(bookingId))!;
    },
    addEvent: async (newEventData: Omit<Event, 'id' | 'booked_capacity' | 'total_capacity'> & {totalCapacity: number, date: Date}): Promise<Event> => {
        const { data, error } = await supabase.from('events').insert({
            title: newEventData.title,
            location: newEventData.location,
            date: newEventData.date.toISOString(),
            total_capacity: newEventData.totalCapacity,
            category: newEventData.category,
            booked_capacity: 0
        }).select().single();
        if (error || !data) throw new Error("Event konnte nicht erstellt werden.");
        return {...data, date: new Date(data.date)};
    },
    updateEvent: async (eventId: string, updatedEventData: Partial<Omit<Event, 'id' | 'date' | 'total_capacity' | 'booked_capacity'>> & { date?: Date; totalCapacity?: number }): Promise<Event> => {
        const payload: any = { ...updatedEventData };
        if (updatedEventData.date) payload.date = updatedEventData.date.toISOString();
        if (updatedEventData.totalCapacity) payload.total_capacity = updatedEventData.totalCapacity;
        delete payload.totalCapacity; // remove camelCase version

        const { data, error } = await supabase.from('events').update(payload).eq('id', eventId).select().single();
        if (error) throw new Error("Event konnte nicht aktualisiert werden.");
        return {...data, date: new Date(data.date)};
    },
    deleteEvent: async (eventId: string): Promise<void> => {
        const { error } = await supabase.from('events').delete().eq('id', eventId);
        if (error) throw new Error("Event konnte nicht gelöscht werden.");
    },
};

// --- HELPER FUNKTIONEN ---
const formatDate = (date: Date) => new Intl.DateTimeFormat('de-DE', { weekday: 'short', day: '2-digit', month: 'short' }).format(date);
const formatTime = (date: Date) => new Intl.DateTimeFormat('de-DE', { hour: '2-digit', minute: '2-digit' }).format(date) + ' Uhr';
const formatMonthYear = (date: Date) => new Intl.DateTimeFormat('de-DE', { month: 'long', year: 'numeric' }).format(date);
const getWeekNumber = (d: Date): number => {
    d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
    d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil((((d.getTime() - yearStart.getTime()) / 86400000) + 1) / 7);
    return weekNo;
}
const toInputDateString = (date: Date) => date.toISOString().split('T')[0];
const toInputTimeString = (date: Date) => date.toTimeString().split(' ')[0].substring(0, 5);


// --- KOMPONENTEN ---

const ForgotPasswordModal = ({ onClose }) => {
    const [email, setEmail] = useState('');
    const [message, setMessage] = useState('');
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        setMessage('');
        setLoading(true);

        try {
            const { error: invokeError } = await supabase.functions.invoke('resend-booking-info', {
                body: { email: email.trim().toLowerCase() }
            });

            if (invokeError) {
                throw new Error("Ein Fehler ist aufgetreten. Bitte versuche es später erneut.");
            }
            
            setMessage("Anfrage erhalten. Wenn für diese E-Mail-Adresse eine Buchung existiert, haben wir dir eine E-Mail mit den Details gesendet.");

        } catch (err) {
            setError(err.message);
        } finally {
            setLoading(false);
        }
    };
    
    return html`
        <div class="modal-overlay" onClick=${onClose}>
            <div class="modal-content" onClick=${e => e.stopPropagation()}>
                <form onSubmit=${handleSubmit}>
                    <div class="modal-header">
                        <h2>Buchungsnummer anfordern</h2>
                        <button type="button" class="modal-close-btn" onClick=${onClose} aria-label="Schließen">&times;</button>
                    </div>
                    <div class="modal-body">
                        ${!message ? html`
                            <p>Gib die E-Mail-Adresse ein, die du bei der Buchung verwendet hast. Wir senden dir dann deine Buchungsnummer(n) zu.</p>
                            <div class="form-group">
                                <label for="recovery-email">E-Mail</label>
                                <input type="email" id="recovery-email" name="email" value=${email} onInput=${e => setEmail(e.target.value)} required autocomplete="email" />
                            </div>
                        ` : ''}
                        
                        ${error && html`<p class="error-message">${error}</p>`}
                        ${message && html`<p class="success-message">${message}</p>`}
                    </div>
                    <div class="modal-footer">
                         <button type="button" class="btn btn-secondary" onClick=${onClose} disabled=${loading}>Abbrechen</button>
                         ${!message && html`
                            <button type="submit" class="btn btn-primary" disabled=${loading}>${loading ? 'Sendet...' : 'Senden'}</button>
                         `}
                    </div>
                </form>
            </div>
        </div>
    `;
};


const EventItem = ({ event, onSelect, isSelected, isLocked }) => {
    const isFull = event.booked_capacity >= event.total_capacity;
    const remaining = event.total_capacity - event.booked_capacity;
    const isDisabled = isFull || isLocked;
    const categoryClass = `event-category-${event.category.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;

    return html`
        <li class=${`event-item ${isDisabled ? 'disabled' : ''} ${categoryClass}`}>
             ${!isFull && !isLocked && html`<input 
                type="checkbox" 
                id=${event.id}
                checked=${isSelected}
                onChange=${() => onSelect(event.id)}
                disabled=${isDisabled}
                aria-label=${`Event ${event.title} auswählen`}
            />`}
            <label for=${isFull || isLocked ? null : event.id} class="event-details">
                <span>${formatDate(event.date)}. – ${formatTime(event.date)} – ${event.title} – ${event.location}</span>
            </label>
            <div class="event-capacity ${isFull ? 'capacity-full' : ''}">
                ${isLocked ? 'Vergangen' : isFull ? 'Leider Ausgebucht' : `${remaining} ${remaining === 1 ? 'Platz' : 'Plätze'} noch frei`}
            </div>
        </li>
    `;
};

const BookingPanel = ({ selectedEvents, customer, onCustomerChange, onSubmit, error, agreedAGB, onAgreedAGBChange, agreedPrivacy, onAgreedPrivacyChange }) => {
    if (selectedEvents.length === 0) {
        return html`
            <div class="booking-summary">
                <h3>Deine Auswahl</h3>
                <p class="empty-state">Wähle links einen oder mehrere Kurse aus, um mit der Anmeldung zu beginnen.</p>
            </div>
        `;
    }

    const handleInput = (e) => {
        onCustomerChange({ ...customer, [e.target.name]: e.target.value });
    };
    
    const showSubmitButton =
        customer.name.trim() !== '' &&
        customer.dog_name.trim() !== '' &&
        customer.email.trim() !== '' &&
        customer.phone.trim() !== '' &&
        agreedAGB &&
        agreedPrivacy;

    return html`
        <div class="booking-panel">
            <div class="booking-form-container">
                 <form onSubmit=${onSubmit}>
                    <h3>Deine Anmeldung</h3>
                    
                    <ul class="selected-event-list">
                        ${selectedEvents.map(event => {
                            const categoryClass = `event-category-${event.category.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
                            return html`
                                <li key=${event.id} class=${`selected-event-item ${categoryClass}`}>
                                    <span>${event.title}</span>
                                    <span class="selected-event-time">${formatDate(event.date)}</span>
                                </li>
                            `
                        })}
                    </ul>

                    <p class="legal-notice">Hiermit melde ich mich rechtsverbindlich für die von mir ausgewählten Unterrichts-Stunden an.</p>
                    <div class="form-group">
                        <label for="name">Name</label>
                        <input type="text" id="name" name="name" value=${customer.name} onInput=${handleInput} required />
                    </div>
                    <div class="form-group">
                        <label for="dogName">Name des Hundes</label>
                        <input type="text" id="dogName" name="dog_name" value=${customer.dog_name} onInput=${handleInput} required />
                    </div>
                     <div class="form-group">
                        <label for="email">E-Mail</label>
                        <input type="email" id="email" name="email" value=${customer.email} onInput=${handleInput} required />
                    </div>
                    <div class="form-group">
                        <label for="phone">Telefon</label>
                        <input type="tel" id="phone" name="phone" value=${customer.phone} onInput=${handleInput} required />
                    </div>
                    
                    <div class="form-group-checkbox">
                        <input type="checkbox" id="agb" name="agb" checked=${agreedAGB} onChange=${e => onAgreedAGBChange(e.target.checked)} required />
                        <label for="agb">Ich habe die <a href="#">AGB's</a> gelesen und akzeptiere sie.</label>
                    </div>
                    <div class="form-group-checkbox">
                        <input type="checkbox" id="privacy" name="privacy" checked=${agreedPrivacy} onChange=${e => onAgreedPrivacyChange(e.target.checked)} required />
                        <label for="privacy">Ich habe die <a href="#">Datenschutzerklärung</a> gelesen und akzeptiere sie.</label>
                    </div>

                    ${error && html`<p class="error-message">${error}</p>`}
                    
                    ${showSubmitButton ? html`
                        <button type="submit" class="btn btn-primary">
                          Rechtsverbindlich anmelden
                        </button>
                    ` : html`
                        <p class="form-hint">Bitte fülle alle Felder aus und akzeptiere die Bedingungen, um die Anmeldung abzuschließen.</p>
                    `}
                 </form>
            </div>
        </div>
    `;
}

const SuccessModal = ({ bookingDetails, onClose }) => {
    if (!bookingDetails) return null;

    return html`
        <div class="modal-overlay" onClick=${onClose}>
            <div class="modal-content" onClick=${e => e.stopPropagation()}>
                <div class="modal-header">
                    <h2>Buchung erfolgreich!</h2>
                    <button class="modal-close-btn" onClick=${onClose} aria-label="Schließen">&times;</button>
                </div>
                <div class="modal-body">
                    <p>Vielen Dank, ${bookingDetails.customerName}!</p>
                    <p>Deine Anmeldung war erfolgreich. Wir haben dir eine Bestätigung per E-Mail gesendet.</p>
                    <p class="booking-id">Deine Buchungsnummer lautet: <strong>${bookingDetails.bookingId}</strong></p>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-primary" onClick=${onClose}>Schließen</button>
                </div>
            </div>
        </div>
    `;
};

const EventFormModal = ({ event, onSave, onClose }) => {
    const [formData, setFormData] = useState({
        title: '',
        location: '',
        date: '',
        time: '',
        totalCapacity: 5,
        category: Object.keys(EVENT_CATEGORIES)[0],
    });

    useEffect(() => {
        if (event) {
            setFormData({
                title: event.title,
                location: event.location,
                date: toInputDateString(event.date),
                time: toInputTimeString(event.date),
                totalCapacity: event.total_capacity,
                category: event.category,
            });
        } else {
             setFormData({
                title: '',
                location: '',
                date: toInputDateString(new Date()),
                time: '10:00',
                totalCapacity: 5,
                category: Object.keys(EVENT_CATEGORIES)[0],
            });
        }
    }, [event]);

    const handleChange = (e) => {
        setFormData({ ...formData, [e.target.name]: e.target.value });
    };

    const handleSubmit = (e) => {
        e.preventDefault();
        const combinedDate = new Date(`${formData.date}T${formData.time}`);
        const eventData = {
            title: formData.title,
            location: formData.location,
            date: combinedDate,
            totalCapacity: Number(formData.totalCapacity),
            category: formData.category,
        };
        onSave(eventData);
    };
    
    return html`
        <div class="modal-overlay" onClick=${onClose}>
            <div class="modal-content" onClick=${e => e.stopPropagation()}>
                <form onSubmit=${handleSubmit}>
                    <div class="modal-header">
                        <h2>${event ? 'Event bearbeiten' : 'Neues Event erstellen'}</h2>
                        <button type="button" class="modal-close-btn" onClick=${onClose} aria-label="Schließen">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label for="title">Titel</label>
                            <input type="text" id="title" name="title" value=${formData.title} onInput=${handleChange} required />
                        </div>
                         <div class="form-group">
                            <label for="location">Treffpunkt</label>
                            <input type="text" id="location" name="location" value=${formData.location} onInput=${handleChange} required />
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label for="date">Datum</label>
                                <input type="date" id="date" name="date" value=${formData.date} onInput=${handleChange} required />
                            </div>
                            <div class="form-group">
                                <label for="time">Uhrzeit</label>
                                <input type="time" id="time" name="time" value=${formData.time} onInput=${handleChange} required />
                            </div>
                        </div>
                         <div class="form-row">
                            <div class="form-group">
                                <label for="totalCapacity">Plätze</label>
                                <input type="number" id="totalCapacity" name="totalCapacity" min="1" value=${formData.totalCapacity} onInput=${handleChange} required />
                            </div>
                            <div class="form-group">
                                <label for="category">Kategorie</label>
                                <select id="category" name="category" value=${formData.category} onChange=${handleChange}>
                                    ${Object.keys(EVENT_CATEGORIES).map(cat => html`<option value=${cat}>${cat}</option>`)}
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                         <button type="button" class="btn btn-secondary" onClick=${onClose}>Abbrechen</button>
                         <button type="submit" class="btn btn-primary">Speichern</button>
                    </div>
                </form>
            </div>
        </div>
    `;
};

const AdminPanel = () => {
    const [events, setEvents] = useState([]);
    const [loading, setLoading] = useState(true);
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [editingEvent, setEditingEvent] = useState(null);

    const loadEvents = async () => {
        setLoading(true);
        const eventsFromApi = await api.getEvents();
        // Die Sortierung kommt jetzt von der API, aber wir filtern weiterhin vergangene Events clientseitig
        const now = new Date();
        const futureEvents = eventsFromApi.filter(e => new Date(e.date) >= now);
        setEvents(futureEvents);
        setLoading(false);
    };

    useEffect(() => {
        loadEvents();
    }, []);

    const handleAdd = () => {
        setEditingEvent(null);
        setIsModalOpen(true);
    };

    const handleEdit = (event) => {
        setEditingEvent(event);
        setIsModalOpen(true);
    };

    const handleDelete = async (eventId) => {
        if (confirm('Bist du sicher, dass du dieses Event löschen möchtest?')) {
            await api.deleteEvent(eventId);
            loadEvents();
        }
    };
    
    const handleSave = async (eventData) => {
        if (editingEvent) {
            await api.updateEvent(editingEvent.id, eventData);
        } else {
            await api.addEvent(eventData);
        }
        setIsModalOpen(false);
        setEditingEvent(null);
        loadEvents();
    };

    if (loading) {
        return html`<div class="loading-state">Lade Events für Admin Panel...</div>`;
    }

    return html`
        <section class="admin-panel">
            <div class="admin-header">
                <h2>Event Verwaltung</h2>
                <button class="btn btn-primary" onClick=${handleAdd}>+ Neues Event</button>
            </div>
            <ul class="admin-event-list">
                ${events.map(event => html`
                    <li key=${event.id} class=${`admin-event-item event-category-${event.category.toLowerCase()}`}>
                       <div class="admin-event-info">
                            <strong>${event.title}</strong>
                            <span>${formatDate(new Date(event.date))} - ${formatTime(new Date(event.date))}</span>
                            <span>Treffpunkt: ${event.location}</span>
                            <span>Plätze: ${event.booked_capacity} / ${event.total_capacity}</span>
                       </div>
                       <div class="admin-event-actions">
                           <button class="btn btn-secondary" onClick=${() => handleEdit(event)}>Bearbeiten</button>
                           <button class="btn btn-danger" onClick=${() => handleDelete(event.id)}>Löschen</button>
                       </div>
                    </li>
                `)}
            </ul>
        </section>
        ${isModalOpen && html`
            <${EventFormModal} 
                event=${editingEvent}
                onSave=${handleSave}
                onClose=${() => setIsModalOpen(false)}
            />
        `}
    `;
};

const BookingManagementPortal = () => {
    const [bookingIdInput, setBookingIdInput] = useState('');
    const [booking, setBooking] = useState<Booking | null>(null);
    const [allEvents, setAllEvents] = useState<Event[]>([]);
    const [managedEventIds, setManagedEventIds] = useState<string[]>([]);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const [successMessage, setSuccessMessage] = useState('');
    const [hasChanges, setHasChanges] = useState(false);
    const [isForgotModalOpen, setIsForgotModalOpen] = useState(false);

    useEffect(() => {
        if (booking) {
            setIsLoading(true);
            api.getEvents().then(events => {
                setAllEvents(events.map(e => ({...e, date: new Date(e.date)})));
                setIsLoading(false);
            });
        }
    }, [booking]);

    useEffect(() => {
        if (booking) {
            setHasChanges(JSON.stringify(booking.bookedEventIds.sort()) !== JSON.stringify(managedEventIds.sort()));
        } else {
            setHasChanges(false);
        }
    }, [managedEventIds, booking]);

    const handleLookup = async (e) => {
        e.preventDefault();
        setError('');
        setSuccessMessage('');
        setIsLoading(true);
        setBooking(null);
        try {
            const foundBooking = await api.getBookingById(bookingIdInput.trim());
            if (foundBooking) {
                setBooking(foundBooking);
                setManagedEventIds(foundBooking.bookedEventIds);
            } else {
                setError('Buchung nicht gefunden. Bitte überprüfe die Buchungsnummer.');
            }
        } catch (err) {
            setError(err.message);
        } finally {
            setIsLoading(false);
        }
    };

    const handleSaveChanges = async () => {
        if (!booking) return;
        setError('');
        setSuccessMessage('');
        setIsLoading(true);
        try {
            const updatedBooking = await api.updateBooking(booking.bookingId, managedEventIds);
            setBooking(updatedBooking); // update local state with the saved data
            setManagedEventIds(updatedBooking.bookedEventIds);
            setSuccessMessage('Deine Buchung wurde erfolgreich aktualisiert!');

            // E-Mail-Versand für Update anstoßen
            try {
                const updatedEventsDetails = allEvents
                    .filter(event => updatedBooking.bookedEventIds.includes(event.id))
                    .map(e => ({
                        title: e.title,
                        date: new Date(e.date).toLocaleString('de-DE', { dateStyle: 'full', timeStyle: 'short' }) + ' Uhr',
                        location: e.location
                    }));
                
                await supabase.functions.invoke('send-smtp-email', {
                    body: {
                        type: 'update-booking',
                        customerName: updatedBooking.customer.name,
                        customerEmail: updatedBooking.customer.email,
                        bookingId: updatedBooking.bookingId,
                        events: updatedEventsDetails
                    }
                });
            } catch (emailError) {
                console.warn("E-Mail-Funktion konnte nicht aufgerufen werden. Stelle sicher, dass die Supabase Edge Function 'send-smtp-email' deployed ist.", emailError);
            }

        } catch (err) {
            setError(err.message);
        } finally {
            setIsLoading(false);
        }
    };

    const handleEventToggle = (eventId: string) => {
        setManagedEventIds(prev =>
            prev.includes(eventId) ? prev.filter(id => id !== eventId) : [...prev, eventId]
        );
    };

    const { bookedEvents, availableEvents } = useMemo(() => {
        if (!booking) return { bookedEvents: [], availableEvents: [] };
        const now = new Date();
        const booked = allEvents
            .filter(e => managedEventIds.includes(e.id) && e.date >= now)
            .sort((a, b) => a.date.getTime() - b.date.getTime());

        const available = allEvents
            .filter(e => {
                if (managedEventIds.includes(e.id)) return false; // Already in selection
                if (e.date < now) return false; // In the past
                if (e.booked_capacity >= e.total_capacity) return false; // Full
                return true;
            })
            .sort((a, b) => a.date.getTime() - b.date.getTime());
        return { bookedEvents: booked, availableEvents: available };
    }, [allEvents, managedEventIds, booking]);

    if (!booking) {
        return html`
            <section class="booking-lookup-form">
                <form onSubmit=${handleLookup}>
                    <h2>Buchung verwalten</h2>
                    <p>Gib deine Buchungsnummer ein, um deine Termine zu bearbeiten.</p>
                    <div class="form-group">
                        <label for="bookingId">Buchungsnummer</label>
                        <input type="text" id="bookingId" name="bookingId" value=${bookingIdInput} onInput=${e => setBookingIdInput(e.target.value)} required placeholder="z.B. Bello-12345" />
                    </div>
                    ${error && html`<p class="error-message">${error}</p>`}
                    <button type="submit" class="btn btn-primary" disabled=${isLoading}>
                        ${isLoading ? 'Sucht...' : 'Buchung suchen'}
                    </button>
                </form>
                 <button class="forgot-booking-id-btn" onClick=${() => setIsForgotModalOpen(true)}>
                    Buchungsnummer vergessen?
                </button>
            </section>
            ${isForgotModalOpen && html`<${ForgotPasswordModal} onClose=${() => setIsForgotModalOpen(false)} />`}
        `;
    }

    return html`
       <section class="manage-portal">
            <h2>Buchungsübersicht für ${booking.customer.name}</h2>
            <p>Buchungsnummer: <strong>${booking.bookingId}</strong></p>

            ${error && html`<p class="error-message">${error}</p>`}
            ${successMessage && html`<p class="success-message">${successMessage}</p>`}

            <div class="manage-container">
                <div class="manage-section">
                    <h3>Deine gebuchten Kurse</h3>
                    ${bookedEvents.length > 0 ? html`
                        <ul class="manage-event-list">
                            ${bookedEvents.map(event => {
                                const hoursUntil = (event.date.getTime() - new Date().getTime()) / (1000 * 60 * 60);
                                const canCancel = hoursUntil >= CANCELLATION_WINDOW_HOURS;
                                const categoryClass = `event-category-${event.category.toLowerCase()}`;
                                return html`
                                    <li key=${event.id} class=${`manage-event-item ${categoryClass}`}>
                                        <div class="manage-event-details">
                                            <strong>${event.title}</strong>
                                            <span>${formatDate(event.date)} - ${formatTime(event.date)}</span>
                                            ${!canCancel && html`<small class="cancel-warning">Stornierung nicht mehr möglich</small>`}
                                        </div>
                                        <button class="btn btn-danger" onClick=${() => handleEventToggle(event.id)} disabled=${!canCancel}>Stornieren</button>
                                    </li>
                                `;
                            })}
                        </ul>
                    ` : html`<p class="empty-state-small">Du hast aktuell keine Kurse gebucht.</p>`}
                </div>
                <div class="manage-section">
                    <h3>Verfügbare Kurse</h3>
                     ${availableEvents.length > 0 ? html`
                        <ul class="manage-event-list">
                            ${availableEvents.map(event => {
                                const categoryClass = `event-category-${event.category.toLowerCase()}`;
                                return html`
                                     <li key=${event.id} class=${`manage-event-item ${categoryClass}`}>
                                        <div class="manage-event-details">
                                            <strong>${event.title}</strong>
                                            <span>${formatDate(event.date)} - ${formatTime(event.date)}</span>
                                            <small>${event.total_capacity - event.booked_capacity} Plätze frei</small>
                                        </div>
                                        <button class="btn btn-success" onClick=${() => handleEventToggle(event.id)}>Buchen</button>
                                    </li>
                                `;
                            })}
                        </ul>
                    ` : html`<p class="empty-state-small">Aktuell sind keine weiteren Kurse verfügbar.</p>`}
                </div>
            </div>
            <div class="manage-footer">
                <button class="btn btn-secondary" onClick=${() => setBooking(null)}>Andere Buchung suchen</button>
                <button class="btn btn-primary" onClick=${handleSaveChanges} disabled=${!hasChanges || isLoading}>
                    ${isLoading ? 'Speichert...' : 'Änderungen speichern'}
                </button>
            </div>
       </section>
    `;
};


const CustomerBookingView = () => {
    const [allEvents, setAllEvents] = useState<Event[]>([]);
    const [loading, setLoading] = useState(true);
    const [selectedEventIds, setSelectedEventIds] = useState<string[]>([]);
    const [customer, setCustomer] = useState<Omit<Customer, 'id'>>({ name: '', phone: '', dog_name: '', email: '' });
    const [bookingError, setBookingError] = useState('');
    const [agreedAGB, setAgreedAGB] = useState(false);
    const [agreedPrivacy, setAgreedPrivacy] = useState(false);
    const [bookingSuccess, setBookingSuccess] = useState(false);
    const [successfulBookingDetails, setSuccessfulBookingDetails] = useState(null);

    const loadInitialData = async () => {
        setLoading(true);
        try {
            const events = await api.getEvents();
            setAllEvents(events);
        } catch (error) {
            setBookingError("Fehler beim Laden der Events. Bitte versuche es später erneut.");
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        loadInitialData();
    }, []);

    const handleSelectEvent = (eventId: string) => {
        setSelectedEventIds(prev =>
            prev.includes(eventId) ? prev.filter(id => id !== eventId) : [...prev, eventId]
        );
    };
    
    const handleCloseModal = () => {
        setBookingSuccess(false);
        setSuccessfulBookingDetails(null);
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setBookingError('');
        try {
            const booking = await api.saveBooking(customer, selectedEventIds);
            setSuccessfulBookingDetails({ bookingId: booking.bookingId, customerName: customer.name });
            setBookingSuccess(true);
            
            // E-Mail-Versand anstoßen
            try {
                const bookedEventsDetails = allEvents
                    .filter(event => selectedEventIds.includes(event.id))
                    .map(e => ({
                        title: e.title,
                        date: new Date(e.date).toLocaleString('de-DE', { dateStyle: 'full', timeStyle: 'short' }) + ' Uhr',
                        location: e.location
                    }));

                await supabase.functions.invoke('send-smtp-email', {
                    body: {
                        type: 'new-booking',
                        customerName: customer.name,
                        customerEmail: customer.email,
                        bookingId: booking.bookingId,
                        events: bookedEventsDetails
                    }
                });
            } catch (emailError) {
                console.warn("E-Mail-Funktion konnte nicht aufgerufen werden. Stelle sicher, dass die Supabase Edge Function 'send-smtp-email' deployed ist.", emailError);
            }

            // Reset state after successful booking
            setSelectedEventIds([]);
            setCustomer({ name: '', phone: '', dog_name: '', email: '' });
            setAgreedAGB(false);
            setAgreedPrivacy(false);
            
            // Reload events to show updated capacity
            loadInitialData();

        } catch (err) {
            setBookingError(err.message);
        }
    }
    
    const { eventsByWeek, selectedEvents } = useMemo(() => {
        const now = new Date();
        const futureEvents = allEvents
            .filter(event => event.date >= now)
            .sort((a, b) => a.date.getTime() - b.date.getTime());

        const groupedByWeek = futureEvents.reduce((acc, event) => {
            const week = getWeekNumber(event.date);
            const year = event.date.getFullYear();
            const key = `${year}-${String(week).padStart(2, '0')}`;

            if (!acc[key]) {
                acc[key] = { events: [] };
            }
            acc[key].events.push(event);
            return acc;
        }, {});

        const sortedKeys = Object.keys(groupedByWeek).sort();

        const eventsByWeek = sortedKeys.map(key => {
            const group = groupedByWeek[key];
            const firstEventDate = group.events[0].date;
            const weekNumber = getWeekNumber(firstEventDate);
            return {
                weekHeader: `${formatMonthYear(firstEventDate)} - Kalenderwoche ${weekNumber}`,
                events: group.events
            };
        });
        
        const selectedEvents = allEvents.filter(event => selectedEventIds.includes(event.id)).sort((a,b) => a.date.getTime() - b.date.getTime());
            
        return { eventsByWeek, selectedEvents };
    }, [allEvents, selectedEventIds]);

    if (loading) {
        return html`<div class="loading-state">Lade Kurstermine...</div>`;
    }
    
    const now = new Date();
    
    return html`
        <main class="main-container">
            <section class="events-section">
                <div class="month-navigator">
                    <h2>Eventliste Hundeschule</h2>
                </div>
                <div class="event-list-container">
                    ${eventsByWeek.length > 0 ? eventsByWeek.map(weekGroup => html`
                        <div class="week-group" key=${weekGroup.weekHeader}>
                            <h3 class="week-header">${weekGroup.weekHeader}</h3>
                            <ul class="event-list">
                                ${weekGroup.events.map(event => {
                                    const isPast = event.date < now;
                                    return html`
                                    <${EventItem} 
                                        key=${event.id}
                                        event=${event}
                                        onSelect=${handleSelectEvent}
                                        isSelected=${selectedEventIds.includes(event.id)}
                                        isLocked=${isPast}
                                    />
                                `})}
                            </ul>
                        </div>
                    `) : html`
                        <p class="empty-state">Aktuell gibt es keine verfügbaren Events.</p>
                    `}
                </div>
            </section>
            
            <aside class="booking-section">
                <${BookingPanel} 
                    selectedEvents=${selectedEvents}
                    customer=${customer}
                    onCustomerChange=${setCustomer}
                    onSubmit=${handleSubmit}
                    error=${bookingError}
                    agreedAGB=${agreedAGB}
                    onAgreedAGBChange=${setAgreedAGB}
                    agreedPrivacy=${agreedPrivacy}
                    onAgreedPrivacyChange=${setAgreedPrivacy}
                />
            </aside>
        </main>
        ${bookingSuccess && html`
            <${SuccessModal} 
                bookingDetails=${successfulBookingDetails}
                onClose=${handleCloseModal}
            />
        `}
    `;
};

const AdminLoginModal = ({ onClose }) => {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        setLoading(true);
        
        const { error: signInError } = await supabase.auth.signInWithPassword({
            email: email,
            password: password,
        });
        
        setLoading(false);

        if (signInError) {
            setError('Falsche E-Mail-Adresse oder Passwort.');
        } else {
            // Success is handled by the onAuthStateChange listener in the App component.
            onClose();
        }
    };

    return html`
        <div class="modal-overlay" onClick=${onClose}>
            <div class="modal-content" onClick=${e => e.stopPropagation()}>
                <form onSubmit=${handleSubmit}>
                    <div class="modal-header">
                        <h2>Admin Login</h2>
                        <button type="button" class="modal-close-btn" onClick=${onClose} aria-label="Schließen">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label for="admin-email">E-Mail</label>
                            <input type="email" id="admin-email" name="email" value=${email} onInput=${e => setEmail(e.target.value)} required autocomplete="email" />
                        </div>
                        <div class="form-group">
                            <label for="admin-password">Passwort</label>
                            <input type="password" id="admin-password" name="password" value=${password} onInput=${e => setPassword(e.target.value)} required autocomplete="current-password" />
                        </div>
                        ${error && html`<p class="error-message">${error}</p>`}
                    </div>
                    <div class="modal-footer">
                         <button type="button" class="btn btn-secondary" onClick=${onClose} disabled=${loading}>Abbrechen</button>
                         <button type="submit" class="btn btn-primary" disabled=${loading}>${loading ? 'Logge ein...' : 'Login'}</button>
                    </div>
                </form>
            </div>
        </div>
    `;
};


const App = () => {
    const [view, setView] = useState('booking');
    const [session, setSession] = useState<Session | null>(null);
    const [isLoginModalOpen, setIsLoginModalOpen] = useState(false);

    useEffect(() => {
        // Fetch the initial session
        supabase.auth.getSession().then(({ data: { session } }) => {
            setSession(session);
        });

        // Listen for changes in auth state (login, logout)
        const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
            setSession(session);
            if (session) { // If a session is established (login successful)
                setIsLoginModalOpen(false);
                setView('admin');
            }
        });

        // Cleanup subscription on component unmount
        return () => subscription.unsubscribe();
    }, []);


    const handleLogout = async () => {
        await supabase.auth.signOut();
        setView('booking');
    };

    return html`
        <header class="booking-tool-header">
            <h1>Kursanmeldung Hundeschule</h1>
            <p>Wähle deine Wunschtermine, verwalte deine Buchungen</p>
            <nav class="main-nav">
                <button class=${`btn ${view === 'booking' ? 'btn-primary' : 'btn-secondary'}`} onClick=${() => setView('booking')}>Kurs buchen</button>
                <button class=${`btn ${view === 'manage' ? 'btn-primary' : 'btn-secondary'}`} onClick=${() => setView('manage')}>Buchung verwalten</button>
                ${session && html`
                    <button class=${`btn ${view === 'admin' ? 'btn-primary' : 'btn-secondary'}`} onClick=${() => setView('admin')}>Admin Panel</button>
                    <button class="btn btn-secondary" onClick=${handleLogout}>Logout</button>
                `}
            </nav>
        </header>

        <main>
            ${view === 'booking' && html`<${CustomerBookingView} />`}
            ${session && view === 'admin' && html`<${AdminPanel} />`}
            ${view === 'manage' && html`<${BookingManagementPortal} />`}
        </main>
        
        ${!session && html`
            <footer class="app-footer">
                <button class="admin-login-btn" onClick=${() => setIsLoginModalOpen(true)}>Admin Login</button>
            </footer>
        `}

        ${isLoginModalOpen && html`
            <${AdminLoginModal} 
                onClose=${() => setIsLoginModalOpen(false)}
            />
        `}
    `;
};


render(html`<${App} />`, document.getElementById('app'));