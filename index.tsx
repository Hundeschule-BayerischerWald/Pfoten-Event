
/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
*/
import { render, h } from 'preact';
import { useState, useEffect, useMemo, useRef } from 'preact/hooks';
import htm from 'htm';
import { Session, RealtimeChannel } from '@supabase/supabase-js';
import { supabase } from './supabaseClient';

const html = htm.bind(h);

// --- KONFIGURATION ---
const CANCELLATION_WINDOW_HOURS = 24; // Stornierungen/Änderungen nur bis 24h vor dem Event möglich

const EVENT_CATEGORIES = {
    "Orchid": { titles: ["Welpenstunde"], locations: ["Welpenwiese"] },
    "LimeGreen": { titles: ["Level 2 - Grunderziehung"], locations: ["Der sichere Start"] },
    "SkyBlue": { titles: ["Level 3 - Fortgeschrittene"], locations: ["Hundeplatz Ascha"] },
    "Peru": { titles: ["Level 4 - Master Class"], locations: ["Hundeplatz Ascha"] },
    "Gold": { titles: ["Trainerstunde"], locations: ["Nach Absprache"] },
    "White": { titles: ["Theorie: Vorträge & Seminare"], locations: ["Hundeschule Innenbereich"] },
    "DarkKhaki": { titles: ["Praxis: Specials & Workshops"], locations: ["Stadtwald"] },
    "Tomato": { titles: ["Prüfungs-Stunden"], locations: ["Hundeschule Innenbereich"] }
};

const TRAINERS = ["Christian", "Sophie", "Sandra", "Susi", "Petra"];

// --- TYPEN & INTERFACES ---
interface Event {
    id: string;
    date: Date;
    title: string;
    location: string;
    total_capacity: number; // snake_case from db
    booked_capacity: number; // snake_case from db
    category: string;
    trainer: string | null;
}

interface Customer {
    id?: string; // Optional because it's generated by DB
    name: string;
    phone: string;
    dog_name: string; // snake_case from db
    email: string;
}

interface Booking {
    bookingId: string;
    customer: Customer;
    bookedEventIds: string[];
}

interface AppStatus {
    id: number;
    status: 'active' | 'cancelled' | 'partial';
    message: string | null;
    updated_at: string;
}

interface PromoModalData {
    id: number;
    is_active: boolean;
    image_url: string | null;
    updated_at: string;
}


// --- API-SCHICHT (Supabase) ---
const api = {
    adminCancelBooking: async (bookingId: string, eventId: string): Promise<void> => {
        const { error } = await supabase.functions.invoke('admin-cancel-booking', {
            body: { bookingId, eventId }
        });
        if (error) {
            console.error("Error during admin cancellation:", error);
            // Attempt to parse a more specific error message from the function's response
            const errorDetails = (error as any).context?.json?.error || error.message;
            throw new Error(`Die Buchung konnte nicht storniert werden. Grund: ${errorDetails}`);
        }
    },
    getPromoModal: async (): Promise<PromoModalData | null> => {
        const { data, error } = await supabase
            .from('promo_modal')
            .select('id, is_active, image_url, updated_at')
            .eq('is_active', true)
            .order('updated_at', { ascending: false })
            .limit(1)
            .maybeSingle();

        if (error) {
            console.error('Error fetching promo modal:', error);
            return null; // Don't block the app for a promo
        }
        return data;
    },
    getAppStatus: async (): Promise<AppStatus | null> => {
        // Fetches the single status row. Assumes id=1 for the single status entry.
        const { data, error } = await supabase.from('app_status').select('*').eq('id', 1).maybeSingle();
        if (error) {
            console.error('Error fetching app status:', error);
            throw error; // Let the calling function handle the error
        }
        return data;
    },
    updateAppStatus: async (status: 'active' | 'cancelled' | 'partial', message: string): Promise<AppStatus> => {
        const { data, error } = await supabase.from('app_status').upsert({
            id: 1,
            status,
            message,
        }).select().single();
    
        if (error) {
            console.error('Fehler beim Aktualisieren des App-Status (Detail):', JSON.stringify(error, null, 2));
            
            if (error.code === '42501') { // "insufficient_privilege" from Postgres
                throw new Error("Fehlende Berechtigung. Bitte stelle sicher, dass die Rolle 'mitarbeiter' die nötigen Zugriffsrechte für die 'app_status' Tabelle hat. Führe das SQL-Skript aus der Anleitung aus.");
            }
            
            const userMessage = `Status konnte nicht aktualisiert werden. Grund: ${error.message}.`;
            throw new Error(userMessage);
        }
        if (!data) {
             throw new Error("Status konnte nicht aktualisiert werden, da keine Daten von der Datenbank zurückgegeben wurden.");
        }
        return data;
    },
    subscribeToAppStatus: (callback: (newStatus: AppStatus) => void): RealtimeChannel => {
        const channel = supabase.channel('app_status_changes')
            .on(
                'postgres_changes',
                { event: '*', schema: 'public', table: 'app_status', filter: 'id=eq.1' },
                (payload) => {
                    callback(payload.new as AppStatus);
                }
            )
            .subscribe((status, err) => {
                 if (err) {
                    console.error('Realtime subscription error:', err);
                }
            });
        return channel;
    },
    getEvents: async (): Promise<Event[]> => {
        const { data, error } = await supabase.from('events').select('*').order('date', { ascending: true });
        if (error) {
            console.error('Error fetching events:', error);
            throw error;
        }
        // Konvertiere Datum-Strings in Date-Objekte
        return data.map(e => ({...e, date: new Date(e.date)}));
    },
    saveBooking: async (customer: Omit<Customer, 'id'>, eventIds: string[]): Promise<Booking> => {
        // 1. Prüfe, ob Events noch verfügbar sind
        const { data: events, error: eventError } = await supabase.from('events').select('id, title, total_capacity, booked_capacity').in('id', eventIds);
        if (eventError) throw new Error("Fehler beim Prüfen der Events.");
        
        for (const eventId of eventIds) {
            const event = events.find(e => e.id === eventId);
            if (!event || event.booked_capacity >= event.total_capacity) {
                throw new Error(`Event "${event?.title || 'Unbekannt'}" ist leider ausgebucht.`);
            }
        }

        // 2. Prüfe, ob Kunde mit dieser E-Mail bereits existiert
        const { data: existingCustomer } = await supabase.from('customers').select('id').eq('email', customer.email.toLowerCase()).maybeSingle();
        if (existingCustomer) {
            throw new Error('Für diese E-Mail-Adresse existiert bereits eine Buchung. Bitte nutze die "Buchung verwalten"-Funktion.');
        }

        // 3. Erstelle neuen Kunden
        const { data: newCustomer, error: customerError } = await supabase.from('customers').insert({
            name: customer.name,
            phone: customer.phone,
            dog_name: customer.dog_name,
            email: customer.email.toLowerCase()
        }).select().single();

        if (customerError || !newCustomer) {
            throw new Error("Kunde konnte nicht erstellt werden.");
        }

        // 4. Erstelle neue Buchung
        const sanitizedDogName = customer.dog_name.trim().replace(/\s+/g, '-');
        const randomNumber = Math.floor(10000 + Math.random() * 90000);
        const newBookingId = `${sanitizedDogName}-${randomNumber}`;
        const { error: bookingError } = await supabase.from('bookings').insert({
            id: newBookingId,
            customer_id: newCustomer.id
        });

        if (bookingError) {
            // "Rollback" - lösche den eben erstellten Kunden
            await supabase.from('customers').delete().eq('id', newCustomer.id);
            throw new Error("Buchung konnte nicht erstellt werden.");
        }
        
        // 5. Verknüpfe Buchung mit Events
        const bookingEvents = eventIds.map(eventId => ({ booking_id: newBookingId, event_id: eventId }));
        const { error: bookingEventsError } = await supabase.from('bookings_events').insert(bookingEvents);

        if (bookingEventsError) {
             await supabase.from('customers').delete().eq('id', newCustomer.id); // Rollback
             await supabase.from('bookings').delete().eq('id', newBookingId); // Rollback
             throw new Error("Events konnten nicht zur Buchung hinzugefügt werden.");
        }
        
        // 6. Aktualisierung der `booked_capacity` wird nun vom DB-Trigger übernommen.

        return {
            bookingId: newBookingId,
            customer: newCustomer,
            bookedEventIds: eventIds
        };
    },
    getBookingById: async (bookingId: string): Promise<Booking | null> => {
        const { data, error } = await supabase
            .from('bookings')
            .select(`
                id,
                customer:customers (*),
                events:bookings_events (event_id)
            `)
            .eq('id', bookingId)
            .single();

        // Wenn keine Buchung gefunden wird, ein Fehler auftritt oder die Buchung keinen Kunden hat, null zurückgeben.
        if (error || !data || !data.customer) {
            if (error && error.code !== 'PGRST116') { // PGRST116 ist der Fehler "genau eine Zeile", was ok ist, wenn nichts gefunden wird.
                console.error('Error fetching booking:', error);
            }
            if (data && !data.customer) {
                console.error(`Buchung mit ID ${bookingId} gefunden, aber sie hat keinen zugehörigen Kunden.`);
            }
            return null;
        }
        
        // Bei einer "to-one"-Beziehung gibt Supabase ein Objekt zurück, kein Array.
        // Der vorherige Code ging fälschlicherweise von einem Array aus (data.customer[0]), was den Fehler verursachte.
        // FIX: The type from Supabase is inferred incorrectly as an array. Casting to `any` to align with runtime behavior where `data.customer` is an object.
        const customerData = data.customer as any;

        const booking: Booking = {
            bookingId: data.id,
            customer: {
                id: customerData.id,
                name: customerData.name,
                phone: customerData.phone,
                dog_name: customerData.dog_name,
                email: customerData.email,
            },
            bookedEventIds: data.events.map((be: any) => be.event_id),
        };
        return booking;
    },
    updateBooking: async (bookingId: string, newEventIds: string[]): Promise<Booking> => {
        const originalBooking = await api.getBookingById(bookingId);
        if (!originalBooking) throw new Error("Buchung nicht gefunden.");

        const originalEventIds = originalBooking.bookedEventIds;
        const addedIds = newEventIds.filter(id => !originalEventIds.includes(id));
        const removedIds = originalEventIds.filter(id => !newEventIds.includes(id));
        const now = new Date();

        const allEvents = await api.getEvents();

        // Stornierungen prüfen
        for (const removedId of removedIds) {
            const event = allEvents.find(e => e.id === removedId);
            if (event) {
                const hoursUntilEvent = (new Date(event.date).getTime() - now.getTime()) / (1000 * 60 * 60);
                if (hoursUntilEvent < CANCELLATION_WINDOW_HOURS) {
                    throw new Error(`Stornierung für "${event.title}" nicht möglich, da das Event in weniger als 24 Stunden beginnt.`);
                }
            }
        }

        // Neue Buchungen prüfen
        for (const addedId of addedIds) {
            const event = allEvents.find(e => e.id === addedId);
            if (!event || event.booked_capacity >= event.total_capacity) {
                throw new Error(`Event "${event?.title}" ist leider ausgebucht.`);
            }
        }

        // Änderungen in der Datenbank durchführen
        if (removedIds.length > 0) {
            await supabase.from('bookings_events').delete().eq('booking_id', bookingId).in('event_id', removedIds);
            // Die Aktualisierung der `booked_capacity` wird nun vom DB-Trigger übernommen.
        }

        if (addedIds.length > 0) {
            await supabase.from('bookings_events').insert(addedIds.map(id => ({ booking_id: bookingId, event_id: id })));
            // Die Aktualisierung der `booked_capacity` wird nun vom DB-Trigger übernommen.
        }
        
        return (await api.getBookingById(bookingId))!;
    },
    addEvent: async (newEventData: Omit<Event, 'id' | 'booked_capacity' | 'total_capacity'> & {totalCapacity: number, date: Date}): Promise<Event> => {
        const { data, error } = await supabase.from('events').insert({
            title: newEventData.title,
            location: newEventData.location,
            date: newEventData.date.toISOString(),
            total_capacity: newEventData.totalCapacity,
            category: newEventData.category,
            trainer: newEventData.trainer,
            booked_capacity: 0
        }).select().single();
        if (error || !data) throw new Error("Event konnte nicht erstellt werden.");
        return {...data, date: new Date(data.date)};
    },
    addEvents: async (eventsData: any[]): Promise<Event[]> => {
        const eventsToInsert = eventsData.map(e => ({
            title: e.title,
            location: e.location || "Hundeplatz Ascha", // Default location
            date: e.date.toISOString(),
            total_capacity: e.totalCapacity,
            category: e.category,
            booked_capacity: 0
        }));

        const { data, error } = await supabase.from('events').insert(eventsToInsert).select();
        if (error || !data) throw new Error("Events konnten nicht erstellt werden. " + error?.message);

        return data.map(e => ({...e, date: new Date(e.date)}));
    },
    updateEvent: async (eventId: string, updatedEventData: Partial<Omit<Event, 'id' | 'date' | 'total_capacity' | 'booked_capacity'>> & { date?: Date; totalCapacity?: number }): Promise<Event> => {
        // 1. Teilnehmer und deren Booking-IDs vor der Aktualisierung abrufen
        const { data: eventWithBookings, error: fetchError } = await supabase
            .from('events')
            .select('*, bookings_events(bookings(id, customers(*)))')
            .eq('id', eventId)
            .single();

        if (fetchError) {
            throw new Error("Fehler beim Abrufen der Event-Teilnehmer.");
        }
        
        // Vergleichen, um Änderungen für die E-Mail zu finden
        const originalEvent = eventWithBookings;
        const changes: { [key: string]: { from: string; to: string } } = {};

        if (updatedEventData.title && updatedEventData.title !== originalEvent.title) {
            changes.title = { from: originalEvent.title, to: updatedEventData.title };
        }
        if (updatedEventData.location && updatedEventData.location !== originalEvent.location) {
            changes.location = { from: originalEvent.location, to: updatedEventData.location };
        }
        if (updatedEventData.date && updatedEventData.date.getTime() !== new Date(originalEvent.date).getTime()) {
            changes.date = {
                from: new Date(originalEvent.date).toLocaleString('de-DE', { dateStyle: 'full', timeStyle: 'short' }) + ' Uhr',
                to: new Date(updatedEventData.date).toLocaleString('de-DE', { dateStyle: 'full', timeStyle: 'short' }) + ' Uhr'
            };
        }

        const hasRelevantChanges = Object.keys(changes).length > 0;
        
        const participants = eventWithBookings?.bookings_events
            .map(be => ({
                customer: be.bookings?.customers,
                bookingId: be.bookings?.id,
            }))
            .filter(p => p.customer && p.bookingId) ?? [];
        
        // 2. Event aktualisieren
        const payload: any = { ...updatedEventData };
        if (updatedEventData.date) payload.date = updatedEventData.date.toISOString();
        if (updatedEventData.totalCapacity) payload.total_capacity = updatedEventData.totalCapacity;
        delete payload.totalCapacity; // camelCase-Version entfernen

        const { data, error = null } = await supabase.from('events').update(payload).eq('id', eventId).select().single();
        if (error) throw new Error("Event konnte nicht aktualisiert werden.");
        
        const updatedEventResult = {...data, date: new Date(data.date)};

        // 3. Benachrichtigungen nur senden, wenn relevante Änderungen vorliegen und Teilnehmer vorhanden sind
        if (participants.length > 0 && hasRelevantChanges) {
            try {
                await supabase.functions.invoke('send-update-notification', {
                    body: {
                        participants: participants,
                        event: {
                            title: updatedEventResult.title,
                            date: new Date(updatedEventResult.date).toLocaleString('de-DE', { dateStyle: 'full', timeStyle: 'short' }) + ' Uhr',
                            location: updatedEventResult.location,
                            category: updatedEventResult.category
                        },
                        changes: changes // Das Objekt mit den Änderungen übergeben
                    }
                });
            } catch (invokeError) {
                // Fehler loggen, aber den Vorgang nicht abbrechen.
                // Die Event-Aktualisierung ist wichtiger als die Benachrichtigung.
                console.warn("Benachrichtigungs-E-Mail über Event-Änderung konnte nicht gesendet werden:", invokeError);
            }
        }
        
        return updatedEventResult;
    },
    deleteEvent: async (eventId: string): Promise<void> => {
        // Zuerst prüfen, ob Buchungen für dieses Event existieren
        const { count, error: countError } = await supabase
            .from('bookings_events')
            .select('*', { count: 'exact', head: true })
            .eq('event_id', eventId);

        if (countError) {
            throw new Error("Fehler beim Prüfen der Event-Buchungen.");
        }
        if (count > 0) {
            throw new Error(`Dieses Event kann nicht gelöscht werden, da bereits ${count} Buchung(en) dafür existieren.`);
        }
        
        // Wenn keine Buchungen vorhanden sind, das Event löschen
        const { error: deleteError } = await supabase.from('events').delete().eq('id', eventId);
        if (deleteError) {
            throw new Error("Event konnte nicht gelöscht werden.");
        }
    },
    cleanupOldEvents: async (): Promise<{ deletedCount: number }> => {
        const { data, error } = await supabase.functions.invoke('cleanup-old-events');
        
        if (error) {
            console.error("Error invoking cleanup function:", error);
            const detailedMessage = error.message || "Unbekannter Fehler.";
            throw new Error(`Fehler beim Aufräumen der Events: ${detailedMessage}`);
        }
        
        // Prüfe auch auf einen anwendungsseitigen Fehler, der von der Funktion zurückgegeben wird
        if (data && data.success === false) {
             console.error("Cleanup function returned a failure status:", data.details);
             throw new Error(`Die Aufräumfunktion hat einen Fehler gemeldet: ${data.details || 'Keine Details.'}`);
        }
        
        return data;
    },
};

// --- HELPER FUNKTIONEN ---
const formatDate = (date: Date) => new Intl.DateTimeFormat('de-DE', { weekday: 'short', day: '2-digit', month: 'short' }).format(date);
const formatTime = (date: Date) => new Intl.DateTimeFormat('de-DE', { hour: '2-digit', minute: '2-digit' }).format(date) + ' Uhr';
const formatStatusTime = (date: Date) => new Intl.DateTimeFormat('de-DE', { hour: '2-digit', minute: '2-digit' }).format(date);
const formatMonthYear = (date: Date) => new Intl.DateTimeFormat('de-DE', { month: 'short', year: 'numeric' }).format(date);
const getWeekNumber = (d: Date): number => {
    d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
    d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil((((d.getTime() - yearStart.getTime()) / 86400000) + 1) / 7);
    return weekNo;
}
const toInputDateString = (date: Date): string => {
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    return `${year}-${month}-${day}`;
};
const toInputTimeString = (date: Date): string => {
    const hours = date.getHours().toString().padStart(2, '0');
    const minutes = date.getMinutes().toString().padStart(2, '0');
    return `${hours}:${minutes}`;
};


// --- KOMPONENTEN ---

const AppSwitcher = () => {
    const [isDragging, setIsDragging] = useState(false);
    const [position, setPosition] = useState(0); // 0 to 100%
    const sliderRef = useRef(null);

    const handleStart = (e) => {
        setIsDragging(true);
    };

    const handleMove = (e) => {
        if (!isDragging || !sliderRef.current) return;
        
        const rect = sliderRef.current.getBoundingClientRect();
        const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
        const relativeX = clientX - rect.left;
        let percentage = (relativeX / rect.width) * 100;
        
        // Clamp between 0 and 100
        percentage = Math.max(0, Math.min(100, percentage));
        setPosition(percentage);
    };

    const handleEnd = () => {
        if (!isDragging) return;
        setIsDragging(false);
        
        if (position > 85) {
            // Trigger navigation
            window.location.href = "https://pfotencard.vercel.app/";
        } else {
            // Snap back
            setPosition(0);
        }
    };

    useEffect(() => {
        if (isDragging) {
            window.addEventListener('mousemove', handleMove);
            window.addEventListener('mouseup', handleEnd);
            window.addEventListener('touchmove', handleMove);
            window.addEventListener('touchend', handleEnd);
        } else {
            window.removeEventListener('mousemove', handleMove);
            window.removeEventListener('mouseup', handleEnd);
            window.removeEventListener('touchmove', handleMove);
            window.removeEventListener('touchend', handleEnd);
        }
        return () => {
            window.removeEventListener('mousemove', handleMove);
            window.removeEventListener('mouseup', handleEnd);
            window.removeEventListener('touchmove', handleMove);
            window.removeEventListener('touchend', handleEnd);
        };
    }, [isDragging, position]);

    return html`
        <div class="app-slider-container" ref=${sliderRef}>
            <div class="slider-track">
                <div class="slider-labels">
                    <div class="slider-option left ${position < 50 ? 'active' : ''}">
                        <img src="https://hs-bw.com/wp-content/uploads/2025/10/Pfoten-Card-Icon.png" alt="Card" class="segmented-icon" />
                        <span>Pfoten-Event</span>
                    </div>
                    <div class="slider-option right ${position >= 50 ? 'active' : ''}">
                        <img src="https://hs-bw.com/wp-content/uploads/2024/02/WhatsApp-Huschu.png" alt="Card" class="segmented-icon" />
                        <span>Pfoten-Card</span>
                    </div>
                </div>

                <div 
                    class="slider-handle" 
                    style=${{ 
                        transform: `translateX(calc(${position}/100 * (100% - var(--handle-width) - 12px)))`,
                        transition: isDragging ? 'none' : 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)' 
                    }}
                    onMouseDown=${handleStart}
                    onTouchStart=${handleStart}
                >
                    <div class="handle-inner"></div>
                </div>
            </div>
            <div class="slider-hint">Schiebe nach rechts zum Wechseln</div>
        </div>
    `;
};

const PromoModal = ({ data, onClose }) => {
    if (!data.image_url) return null;

    return html`
        <div class="promo-modal-overlay" onClick=${onClose}>
            <div class="promo-modal-content" onClick=${e => e.stopPropagation()}>
                <button type="button" class="modal-close-btn" onClick=${onClose} aria-label="Schließen">×</button>
                <img src=${data.image_url} alt="Aktueller Flyer" class="promo-modal-image" />
            </div>
        </div>
    `;
};

const LiveStatusBanner = ({ statusData }) => {
    if (!statusData || !statusData.status) {
        return null;
    }

    const isCancelled = statusData.status === 'cancelled';
    const isPartial = statusData.status === 'partial';
    const bannerClass = `status-banner ${isCancelled ? 'is-cancelled' : isPartial ? 'is-partial' : 'is-active'}`;
    const defaultMessage = isCancelled
        ? 'Die Hundeschule fällt aus.'
        : isPartial
        ? 'Einschränkungen im Betrieb. Bitte Details beachten.'
        : 'Alle Stunden finden wie geplant statt.';

    const CheckIcon = () => html`
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="status-banner-icon">
            <path d="M20 6 9 17l-5-5"/>
        </svg>
    `;
    const CrossIcon = () => html`
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="status-banner-icon">
            <path d="M18 6 6 18"/><path d="m6 6 12 12"/>
        </svg>
    `;
    const WarningIcon = () => html`
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="status-banner-icon">
            <path d="m21.73 18-8-14a2 2 0 0 0-3.46 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/>
        </svg>
    `;

    return html`
        <div class=${bannerClass} role="alert" aria-live="polite">
            ${isCancelled ? html`<${CrossIcon} />` : isPartial ? html`<${WarningIcon} />` : html`<${CheckIcon} />`}
            <div class="status-banner-content">
                <p class="status-banner-message">${statusData.message || defaultMessage}</p>
                <p class="status-banner-time">
                    Status aktualisiert um ${formatStatusTime(new Date(statusData.updated_at))} Uhr
                </p>
            </div>
        </div>
    `;
};

const EventLegend = () => {
    return html`
        <div class="event-legend">
            <h4>Legende</h4>
            <ul class="legend-list">
                ${Object.entries(EVENT_CATEGORIES).map(([color, details]) => {
                    const categoryClass = `event-category-${color.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
                    // Use the first title as the representative name for the legend
                    const representativeTitle = details.titles[0];
                    return html`
                        <li class="legend-item" key=${color}>
                            <span class=${`legend-color-swatch ${categoryClass}`}></span>
                            <span>${representativeTitle}</span>
                        </li>
                    `;
                })}
            </ul>
        </div>
    `;
};

const ForgotPasswordModal = ({ onClose }) => {
    const [email, setEmail] = useState('');
    const [message, setMessage] = useState('');
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        setMessage('');
        setLoading(true);

        try {
            const { error: invokeError } = await supabase.functions.invoke('resend-booking-info', {
                body: { 
                    email: email.trim().toLowerCase()
                }
            });

            if (invokeError) {
                throw new Error("Ein Fehler ist aufgetreten. Bitte versuche es später erneut.");
            }
            
            setMessage("Anfrage erhalten. Wenn für diese E-Mail-Adresse eine Buchung existiert, haben wir dir eine E-Mail mit den Details gesendet.");

        } catch (err) {
            setError(err.message);
        } finally {
            setLoading(false);
        }
    };
    
    return html`
        <div class="modal-overlay" onClick=${onClose}>
            <div class="modal-content" onClick=${e => e.stopPropagation()}>
                <form onSubmit=${handleSubmit}>
                    <div class="modal-header">
                        <h2>Buchungsnummer anfordern</h2>
                        <button type="button" class="modal-close-btn" onClick=${onClose} aria-label="Schließen">×</button>
                    </div>
                    <div class="modal-body">
                        ${!message ? html`
                            <p>Gib die E-Mail-Adresse ein, die du bei der Buchung verwendet hast. Wir senden dir dann deine Buchungsnummer(n) zu.</p>
                            <div class="form-group">
                                <label for="recovery-email">E-Mail</label>
                                <input type="email" id="recovery-email" name="email" value=${email} onInput=${e => setEmail(e.target.value)} required autocomplete="email" />
                            </div>
                        ` : ''}
                        
                        ${error && html`<p class="error-message">${error}</p>`}
                        ${message && html`<p class="success-message">${message}</p>`}
                    </div>
                    <div class="modal-footer">
                         ${!message ? html`
                            <button type="button" class="btn btn-secondary" onClick=${onClose} disabled=${loading}>Abbrechen</button>
                            <button type="submit" class="btn btn-primary" disabled=${loading}>${loading ? 'Sendet...' : 'Senden'}</button>
                         ` : html `
                            <button type="button" class="btn btn-primary" onClick=${onClose}>Zurück zum Portal</button>
                         `}
                    </div>
                </form>
            </div>
        </div>
    `;
};


const EventItem = ({ event, onSelect, isSelected, isLocked }) => {
    const isFull = event.booked_capacity >= event.total_capacity;
    const remaining = event.total_capacity - event.booked_capacity;
    const isDisabled = isFull || isLocked;
    const categoryClass = `event-category-${event.category.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;

    return html`
        <li class=${`event-item ${isDisabled ? 'disabled' : ''} ${categoryClass}`}>
             ${!isFull && !isLocked && html`<input 
                type="checkbox" 
                id=${event.id}
                checked=${isSelected}
                onChange=${() => onSelect(event.id)}
                disabled=${isDisabled}
                aria-label=${`Event ${event.title} auswählen`}
            />`}
            <label for=${isFull || isLocked ? null : event.id} class="event-details">
                <span>${formatDate(event.date)} – ${formatTime(event.date)} – ${event.title} – ${event.location}</span>
            </label>
            <div class="event-capacity ${isFull ? 'capacity-full' : ''}">
                ${isLocked ? 'Vergangen' : isFull ? 'Leider Ausgebucht' : `${remaining} ${remaining === 1 ? 'Platz' : 'Plätze'} noch frei`}
            </div>
        </li>
    `;
};

const BookingPanel = ({ selectedEvents, customer, onCustomerChange, onSubmit, error, agreedAGB, onAgreedAGBChange, agreedPrivacy, onAgreedPrivacyChange }) => {
    if (selectedEvents.length === 0) {
        return html`
            <div class="booking-summary">
                <h3>Deine Auswahl</h3>
                <p class="empty-state">Wähle ein oder mehrere Events aus, um mit der Anmeldung zu beginnen.</p>
            </div>
        `;
    }

    const handleInput = (e) => {
        onCustomerChange({ ...customer, [e.target.name]: e.target.value });
    };
    
    const showSubmitButton =
        customer.name.trim() !== '' &&
        customer.dog_name.trim() !== '' &&
        customer.email.trim() !== '' &&
        customer.phone.trim() !== '' &&
        agreedAGB &&
        agreedPrivacy;

    return html`
        <div class="booking-panel">
            <div class="booking-form-container">
                 <form onSubmit=${onSubmit}>
                    <h3>Deine Anmeldung</h3>
                    
                    <ul class="selected-event-list">
                        ${selectedEvents.map(event => {
                            const categoryClass = `event-category-${event.category.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
                            return html`
                                <li key=${event.id} class=${`selected-event-item ${categoryClass}`}>
                                    <span>${event.title}</span>
                                    <span class="selected-event-time">${formatDate(event.date)}</span>
                                </li>
                            `
                        })}
                    </ul>

                    <p class="legal-notice">Hiermit melde ich mich rechtsverbindlich für die von mir ausgewählten Unterrichts-Stunden an. *</p>
                    <div class="form-group">
                        <label for="name">Name *</label>
                        <input type="text" id="name" name="name" value=${customer.name} onInput=${handleInput} required />
                    </div>
                    <div class="form-group">
                        <label for="dogName">Name des Hundes *</label>
                        <input type="text" id="dogName" name="dog_name" value=${customer.dog_name} onInput=${handleInput} required />
                    </div>
                     <div class="form-group">
                        <label for="email">E-Mail *</label>
                        <input type="email" id="email" name="email" value=${customer.email} onInput=${handleInput} required />
                    </div>
                    <div class="form-group">
                        <label for="phone">Telefon *</label>
                        <input type="tel" id="phone" name="phone" value=${customer.phone} onInput=${handleInput} required />
                    </div>
                    
                    <div class="form-group-checkbox">
                        <input type="checkbox" id="agb" name="agb" checked=${agreedAGB} onChange=${e => onAgreedAGBChange(e.target.checked)} required />
                        <label for="agb">Ich habe die <a href="https://drive.google.com/file/d/19fR6ruOHCrSdr3QawbLiis47rUKNVzM9/view?usp=sharing" target="_blank" rel="noopener noreferrer">AGB</a> gelesen und akzeptiere sie.</label>
                    </div>
                    <div class="form-group-checkbox">
                        <input type="checkbox" id="privacy" name="privacy" checked=${agreedPrivacy} onChange=${e => onAgreedPrivacyChange(e.target.checked)} required />
                        <label for="privacy">Ich habe die <a href="/datenschutz" target="_blank" rel="noopener noreferrer">Datenschutzerklärung</a> gelesen und akzeptiere sie.</label>
                    </div>

                    ${error && html`<p class="error-message">${error}</p>`}
                    
                    ${showSubmitButton ? html`
                        <button type="submit" class="btn btn-primary">
                          Rechtsverbindlich anmelden
                        </button>
                    ` : html`
                        <p class="form-hint">Bitte fülle alle Felder aus und akzeptiere die Bedingungen, um die Anmeldung abzuschließen.</p>
                    `}
                 </form>
            </div>
        </div>
    `;
}

const SuccessModal = ({ bookingDetails, onClose }) => {
    if (!bookingDetails) return null;

    return html`
        <div class="modal-overlay" onClick=${onClose}>
            <div class="modal-content" onClick=${e => e.stopPropagation()}>
                <div class="modal-header">
                    <h2>Buchung erfolgreich!</h2>
                    <button class="modal-close-btn" onClick=${onClose} aria-label="Schließen">×</button>
                </div>
                <div class="modal-body">
                    <p>Vielen Dank, ${bookingDetails.customerName}!</p>
                    <p>Deine Anmeldung war erfolgreich. Wir haben dir eine Bestätigung per E-Mail gesendet.</p>
                    <p class="booking-id">Deine Buchungsnummer lautet: <strong>${bookingDetails.bookingId}</strong></p>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-primary" onClick=${onClose}>Schließen</button>
                </div>
            </div>
        </div>
    `;
};

const EmailExistsModal = ({ email, onClose, onGoToManage, onForgotPassword }) => {
    return html`
        <div class="modal-overlay" onClick=${onClose}>
            <div class="modal-content" onClick=${e => e.stopPropagation()}>
                <div class="modal-header">
                    <h2>E-Mail-Adresse bereits registriert</h2>
                    <button type="button" class="modal-close-btn" onClick=${onClose} aria-label="Schließen">×</button>
                </div>
                <div class="modal-body">
                    <p>Für die E-Mail-Adresse <strong>${email}</strong> existiert bereits eine Buchung. Du kannst keine neue Anmeldung erstellen.</p>
                    <p>Möchtest du deine bestehende Buchung verwalten oder deine Buchungsnummer anfordern?</p>
                </div>
                <div class="modal-footer">
                     <button type="button" class="btn btn-secondary" onClick=${onForgotPassword}>Buchungsnummer vergessen?</button>
                     <button type="button" class="btn btn-primary" onClick=${onGoToManage}>Zur Buchungsverwaltung</button>
                </div>
            </div>
        </div>
    `;
};


const EventFormModal = ({ event, onSave, onClose }) => {
    const [formData, setFormData] = useState({
        title: '',
        location: '',
        date: '',
        time: '',
        totalCapacity: 6,
        category: Object.keys(EVENT_CATEGORIES)[0],
        trainer: '',
    });

    useEffect(() => {
        if (event) {
            setFormData({
                title: event.title,
                location: event.location,
                date: toInputDateString(event.date),
                time: toInputTimeString(event.date),
                totalCapacity: event.total_capacity,
                category: event.category,
                trainer: event.trainer || '',
            });
        } else {
             const defaultDate = new Date();
             defaultDate.setHours(10, 0, 0, 0);
             setFormData({
                title: '',
                location: '',
                date: toInputDateString(defaultDate),
                time: toInputTimeString(defaultDate),
                totalCapacity: 6,
                category: Object.keys(EVENT_CATEGORIES)[0],
                trainer: '',
            });
        }
    }, [event]);

    const handleChange = (e) => {
        setFormData({ ...formData, [e.target.name]: e.target.value });
    };

    const handleSubmit = (e) => {
        e.preventDefault();
        const combinedDate = new Date(`${formData.date}T${formData.time}`);
        const eventData = {
            title: formData.title,
            location: formData.location,
            date: combinedDate,
            totalCapacity: Number(formData.totalCapacity),
            category: formData.category,
            trainer: formData.trainer || null,
        };
        onSave(eventData);
    };
    
    return html`
        <div class="modal-overlay" onClick=${onClose}>
            <div class="modal-content" onClick=${e => e.stopPropagation()}>
                <form onSubmit=${handleSubmit}>
                    <div class="modal-header">
                        <h2>${event && event.id ? 'Event bearbeiten' : 'Neues Event erstellen'}</h2>
                        <button type="button" class="modal-close-btn" onClick=${onClose} aria-label="Schließen">×</button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label for="title">Titel</label>
                            <input type="text" id="title" name="title" value=${formData.title} onInput=${handleChange} required />
                        </div>
                         <div class="form-group">
                            <label for="location">Treffpunkt</label>
                            <input type="text" id="location" name="location" value=${formData.location} onInput=${handleChange} placeholder="Standard: Hundeplatz Ascha" />
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label for="date">Datum</label>
                                <input type="date" id="date" name="date" value=${formData.date} onInput=${handleChange} required />
                            </div>
                            <div class="form-group">
                                <label for="time">Uhrzeit</label>
                                <input type="time" id="time" name="time" value=${formData.time} onInput=${handleChange} required />
                            </div>
                        </div>
                         <div class="form-row">
                            <div class="form-group">
                                <label for="totalCapacity">Plätze</label>
                                <input type="number" id="totalCapacity" name="totalCapacity" min="1" value=${formData.totalCapacity} onInput=${handleChange} required />
                            </div>
                            <div class="form-group">
                                <label for="category">Kategorie</label>
                                <select id="category" name="category" value=${formData.category} onChange=${handleChange}>
                                    ${Object.keys(EVENT_CATEGORIES).map(cat => html`<option value=${cat}>${cat}</option>`)}
                                </select>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="trainer">Trainer</label>
                            <select id="trainer" name="trainer" value=${formData.trainer} onChange=${handleChange}>
                                <option value="">Kein Trainer</option>
                                ${TRAINERS.map(t => html`<option key=${t} value=${t}>${t}</option>`)}
                            </select>
                        </div>
                    </div>
                    <div class="modal-footer">
                         <button type="button" class="btn btn-secondary" onClick=${onClose}>Abbrechen</button>
                         <button type="submit" class="btn btn-primary">Speichern</button>
                    </div>
                </form>
            </div>
        </div>
    `;
};

const ConfirmDeleteModal = ({ onConfirm, onClose, error, loading }) => {
    return html`
        <div class="modal-overlay" onClick=${onClose}>
            <div class="modal-content" onClick=${e => e.stopPropagation()}>
                <div class="modal-header">
                    <h2>Löschen bestätigen</h2>
                    <button type="button" class="modal-close-btn" onClick=${onClose} aria-label="Schließen">×</button>
                </div>
                <div class="modal-body">
                    <p>Bist du sicher, dass du dieses Event endgültig löschen möchtest?</p>
                    <p><strong>Diese Aktion kann nicht rückgängig gemacht werden.</strong></p>
                    ${error && html`<p class="error-message">${error}</p>`}
                </div>
                <div class="modal-footer">
                     <button type="button" class="btn btn-secondary" onClick=${onClose} disabled=${loading}>Abbrechen</button>
                     <button 
                        type="button" 
                        class="btn btn-danger" 
                        onClick=${onConfirm}
                        disabled=${loading}
                     >
                        ${loading ? 'Lösche...' : 'Ja, endgültig löschen'}
                     </button>
                </div>
            </div>
        </div>
    `;
};

const ConfirmActionModal = ({ isOpen, onClose, onConfirm, title, message, confirmText, loading, error }) => {
    if (!isOpen) return null;

    return html`
        <div class="modal-overlay" onClick=${onClose}>
            <div class="modal-content" onClick=${e => e.stopPropagation()}>
                <div class="modal-header">
                    <h2>${title}</h2>
                    <button type="button" class="modal-close-btn" onClick=${onClose} aria-label="Schließen">×</button>
                </div>
                <div class="modal-body">
                    <p>${message}</p>
                    ${error && html`<p class="error-message">${error}</p>`}
                </div>
                <div class="modal-footer">
                     <button type="button" class="btn btn-secondary" onClick=${onClose} disabled=${loading}>Abbrechen</button>
                     <button type="button" class="btn btn-warning" onClick=${onConfirm} disabled=${loading}>
                        ${loading ? 'Sendet...' : confirmText}
                     </button>
                </div>
            </div>
        </div>
    `;
};

// --- MONITOR VIEW COMPONENT ---
const MonitorView = () => {
    const [currentTime, setCurrentTime] = useState(new Date());
    const [events, setEvents] = useState([]);
    const [loading, setLoading] = useState(true);

    // Clock ticker (every second)
    useEffect(() => {
        const timer = setInterval(() => setCurrentTime(new Date()), 1000);
        return () => clearInterval(timer);
    }, []);

    // Data fetching (every 60 seconds)
    useEffect(() => {
        const fetchTodayEvents = async () => {
            const today = new Date();
            const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate()).toISOString();
            const endOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 1).toISOString();

            const { data, error } = await supabase
                .from('events')
                .select('*, bookings_events(bookings(customers(name, dog_name)))')
                .gte('date', startOfDay)
                .lt('date', endOfDay)
                .order('date', { ascending: true });
            
            if (!error && data) {
                // Parse dates and flatten structure
                const parsedEvents = data.map(e => ({
                    ...e,
                    date: new Date(e.date),
                    participants: e.bookings_events.map(be => be.bookings?.customers).filter(Boolean)
                }));
                setEvents(parsedEvents);
            }
            setLoading(false);
        };

        fetchTodayEvents(); // Initial fetch
        const dataTimer = setInterval(fetchTodayEvents, 60000); // Poll every minute
        return () => clearInterval(dataTimer);
    }, []);

    if (loading) return html`<div class="monitor-view"><div class="monitor-idle"><h2>Lade Daten...</h2></div></div>`;

    // --- LOGIC: What to show ---
    const now = currentTime;
    
    // Find "Current" event: Starts before now, ends after now (assuming 60 min duration)
    // Actually, let's just use start time. If it started within the last 60 mins.
    const currentEvent = events.find(e => {
        const start = e.date.getTime();
        const end = start + (60 * 60 * 1000); // 1 hour duration assumption
        return now.getTime() >= start && now.getTime() < end;
    });

    // Find "Next" event: The first event that starts in the future
    const nextEvent = events.find(e => e.date.getTime() > now.getTime());

    // Layout Logic
    let layout = 'idle'; // 'idle', 'single', 'split'

    // Condition 1: Transition phase (15 mins before next class)
    if (nextEvent) {
        const msUntilNext = nextEvent.date.getTime() - now.getTime();
        const minsUntilNext = msUntilNext / (1000 * 60);

        if (minsUntilNext <= 15) {
            // If current is running OR we are just waiting, show split view to show upcoming class
            layout = 'split'; 
        } else if (currentEvent) {
            // Current is running, next is far away -> Show just current
            layout = 'single';
        } else if (minsUntilNext <= 30) {
            // No current event, but next starts in 30 mins -> Show next as "Upcoming"
             layout = 'single-next';
        }
    } else if (currentEvent) {
        // Only current event exists today
        layout = 'single';
    }

    // Helper to render an event card
    const renderEventCard = (event, label) => {
        if (!event) return null;
        const color = event.category.toLowerCase(); // Map this to specific hex if needed, CSS classes handle it?
        // Using inline styles for specific colors on the dark theme
        const colorMap = {
            'orchid': 'Orchid',
            'limegreen': 'LimeGreen',
            'skyblue': 'SkyBlue',
            'peru': 'Peru',
            'gold': 'Gold',
            'white': '#F6F6C9',
            'darkkhaki': 'DarkKhaki',
            'tomato': 'Tomato'
        };
        const borderColor = colorMap[color] || '#fff';

        return html`
            <div class="monitor-card" style="border-left-color: ${borderColor}">
                <div class="monitor-card-header">
                    <span class="monitor-status-badge" style="background-color: ${borderColor}; color: #1a1a1a;">${label}</span>
                    <h2 class="monitor-event-title">${event.title}</h2>
                    <div class="monitor-event-meta">
                        ${formatTime(event.date)} Uhr &bull; ${event.location} &bull; ${event.trainer || 'Kein Trainer'}
                    </div>
                </div>
                <div class="monitor-participants">
                    ${event.participants.map(p => html`
                        <div class="monitor-participant-item">
                            <span class="monitor-dog-name">${p.dog_name}</span>
                            <span class="monitor-owner-name">${p.name.split(' ')[0]}</span> 
                        </div>
                    `)}
                    ${event.participants.length === 0 && html`<p style="color: #666; font-size: 1.2rem; margin-top: 1rem;">Noch keine Anmeldungen.</p>`}
                </div>
            </div>
        `;
    };

    return html`
        <div class="monitor-view">
            <header class="monitor-header">
                <div class="monitor-brand">
                    <img src="https://hs-bw.com/wp-content/uploads/2025/10/Pfoten-Card-Icon.png" alt="Logo" class="monitor-logo" />
                    <div class="monitor-title">
                        <h1>Pfoten-Event Monitor</h1>
                        <p>Willkommen in der Hundeschule</p>
                    </div>
                </div>
                <div class="monitor-clock">
                    <div class="monitor-time">${new Intl.DateTimeFormat('de-DE', { hour: '2-digit', minute: '2-digit' }).format(currentTime)}</div>
                    <div class="monitor-date">${new Intl.DateTimeFormat('de-DE', { weekday: 'long', day: '2-digit', month: 'long', year: 'numeric' }).format(currentTime)}</div>
                </div>
            </header>

            <main class="monitor-content">
                ${layout === 'idle' && html`
                    <div class="monitor-idle">
                        <img src="https://hs-bw.com/wp-content/uploads/2025/10/Pfoten-Card-Icon.png" alt="Logo" class="monitor-idle-logo" />
                        <h2>Kein Kurs aktuell</h2>
                        <p>Der nächste Kurs findet am ${nextEvent ? formatDate(nextEvent.date) + ' um ' + formatTime(nextEvent.date) : 'demnächst'} statt.</p>
                    </div>
                `}

                ${layout === 'single' && html`
                    <div class="monitor-single">
                        ${renderEventCard(currentEvent, 'Jetzt Live')}
                    </div>
                `}

                 ${layout === 'single-next' && html`
                    <div class="monitor-single">
                        ${renderEventCard(nextEvent, 'Als Nächstes')}
                    </div>
                `}

                ${layout === 'split' && html`
                    <div class="monitor-split">
                        <div>
                            ${currentEvent ? renderEventCard(currentEvent, 'Aktuell') : html`
                                <div class="monitor-idle" style="height: 100%; justify-content: flex-start; padding-top: 4rem;">
                                    <h3>Kein laufender Kurs</h3>
                                </div>
                            `}
                        </div>
                        <div>
                            ${renderEventCard(nextEvent, 'In Kürze')}
                        </div>
                    </div>
                `}
            </main>
        </div>
    `;
};


const BookingOverview = ({ userRole }) => {
    const [eventsWithBookings, setEventsWithBookings] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState('');
    const [confirmModalState, setConfirmModalState] = useState({ isOpen: false, data: null, error: '' });
    const [cancelModalState, setCancelModalState] = useState({ isOpen: false, data: null, error: '', loading: false });
    const [sentEmails, setSentEmails] = useState(new Set());
    const [isSending, setIsSending] = useState(false);
    const [testEmail, setTestEmail] = useState('');
    const [testEmailType, setTestEmailType] = useState('no-show');
    const [isSendingTest, setIsSendingTest] = useState(false);
    const [testMessage, setTestMessage] = useState({ text: '', type: '' });

    const loadBookings = async () => {
        setLoading(true);
        setError('');
        try {
            const { data, error: fetchError = null } = await supabase
                .from('events')
                .select('*, bookings_events(bookings(*, customers(*)))')
                .order('date', { ascending: true });

            if (fetchError) throw fetchError;
            
            const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
            const recentEvents = data.filter(event => new Date(event.date) >= twentyFourHoursAgo);
            
            setEventsWithBookings(recentEvents);
        } catch (err) {
            setError('Fehler beim Laden der Buchungsübersicht.');
            console.error(err);
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        loadBookings();
    }, []);
    
    const handleOpenConfirmation = (customer, event) => {
        setConfirmModalState({ isOpen: true, data: { customer, event }, error: '' });
    };

    const handleCloseConfirmation = () => {
        setConfirmModalState({ isOpen: false, data: null, error: '' });
    };

    const handleOpenCancelModal = (booking, customer, event) => {
        setCancelModalState({ isOpen: true, data: { booking, customer, event }, error: '', loading: false });
    };

    const handleCloseCancelModal = () => {
        setCancelModalState({ isOpen: false, data: null, error: '', loading: false });
    };
    
    const handleConfirmAdminCancel = async () => {
        if (!cancelModalState.data) return;
        setCancelModalState(prev => ({ ...prev, loading: true, error: '' }));
        const { booking, event } = cancelModalState.data;

        try {
            await api.adminCancelBooking(booking.id, event.id);
            handleCloseCancelModal();
            loadBookings(); // Reload the list to show the change
        } catch (err) {
            // Check for authentication error (e.g., expired token)
            if (err.message.includes('Token') || err.message.includes('JWT') || err.message.includes('401')) {
                // Dispatch a global event that the App component can listen to
                const authErrorEvent = new CustomEvent('auth-error', { 
                    detail: { message: 'Ihre Sitzung ist abgelaufen. Bitte melden Sie sich erneut an.' }
                });
                window.dispatchEvent(authErrorEvent);
            } else {
                setCancelModalState(prev => ({ ...prev, loading: false, error: err.message }));
            }
        }
    };
    
    const handleSendNoShowEmail = async () => {
        if (!confirmModalState.data) return;
        
        setIsSending(true);
        setConfirmModalState(prev => ({ ...prev, error: '' })); // Clear previous error
        const { customer, event } = confirmModalState.data;
        const sentKey = `${event.id}-${customer.id}`;
        
        try {
            await supabase.functions.invoke('send-smtp-email', {
                body: {
                    type: 'no-show',
                    customerName: customer.name,
                    customerEmail: customer.email,
                    event: {
                        title: event.title,
                        date: new Date(event.date).toLocaleString('de-DE', { dateStyle: 'full', timeStyle: 'short' }) + ' Uhr'
                    }
                }
            });
            setSentEmails(prev => new Set(prev).add(sentKey));
            handleCloseConfirmation();
        } catch (err) {
             setConfirmModalState(prev => ({ ...prev, error: "E-Mail konnte nicht gesendet werden. Bitte versuche es später erneut." }));
        } finally {
            setIsSending(false);
        }
    };

    const handleSendTestEmail = async (e) => {
        e.preventDefault();
        if (!testEmail) {
            setTestMessage({ text: 'Bitte gib eine E-Mail-Adresse ein.', type: 'error' });
            return;
        }
        setIsSendingTest(true);
        setTestMessage({ text: '', type: '' });

        try {
            const body: any = {
                type: testEmailType,
                customerName: 'Max Mustermann (Test)',
                customerEmail: testEmail,
            };

            if (testEmailType === 'no-show') {
                body.event = {
                    title: 'Test-Event: Welpenstunde',
                    date: new Date().toLocaleString('de-DE', { dateStyle: 'full', timeStyle: 'short' }) + ' Uhr'
                };
            } else if (testEmailType === 'new-booking' || testEmailType === 'update-booking') {
                body.bookingId = 'TEST-BELLO-123';
                body.events = [
                    { 
                        title: 'Test-Event: Welpenstunde', 
                        date: new Date().toLocaleString('de-DE', { dateStyle: 'full', timeStyle: 'short' }) + ' Uhr',
                        location: 'Welpenwiese',
                        category: 'Orchid'
                    },
                     { 
                        title: 'Test-Event: Grunderziehung', 
                        date: new Date(Date.now() + 86400000).toLocaleString('de-DE', { dateStyle: 'full', timeStyle: 'short' }) + ' Uhr',
                        location: 'Hundeplatz Ascha',
                        category: 'LimeGreen'
                    }
                ];
            } else if (testEmailType === 'admin-cancellation') {
                body.bookingId = 'TEST-BELLO-123';
                body.cancelledEvent = {
                     title: 'Test-Event: Welpenstunde (Storniert)', 
                     date: new Date().toLocaleString('de-DE', { dateStyle: 'full', timeStyle: 'short' }) + ' Uhr'
                };
                body.events = [
                     { 
                        title: 'Test-Event: Grunderziehung', 
                        date: new Date(Date.now() + 86400000).toLocaleString('de-DE', { dateStyle: 'full', timeStyle: 'short' }) + ' Uhr',
                        location: 'Hundeplatz Ascha',
                        category: 'LimeGreen'
                    }
                ];
            }

            await supabase.functions.invoke('send-smtp-email', { body });
            setTestMessage({ text: `Test-Mail (${testEmailType}) erfolgreich an ${testEmail} gesendet!`, type: 'success' });
        } catch (err) {
            setTestMessage({ text: 'Fehler: Test-Mail konnte nicht gesendet werden.', type: 'error' });
        } finally {
            setIsSendingTest(false);
        }
    };


    if (loading) {
        return html`<div class="loading-state">Lade Buchungsübersicht...</div>`;
    }
    if (error) {
        return html`<p class="error-message">${error}</p>`;
    }

    return html`
        <div class="booking-overview-container">
            ${userRole === 'admin' && html`
                <div class="email-test-container">
                    <h4>System-E-Mails testen</h4>
                    <p style="font-size: 0.85rem; color: #666; margin-bottom: 0.5rem;">Sende dir selbst eine Vorschau der verschiedenen E-Mails, um das Design zu prüfen.</p>
                    <form class="email-test-form" onSubmit=${handleSendTestEmail}>
                        <input 
                            type="email" 
                            placeholder="Deine E-Mail-Adresse" 
                            value=${testEmail} 
                            onInput=${e => setTestEmail(e.target.value)} 
                            required 
                        />
                        <select 
                            value=${testEmailType} 
                            onChange=${e => setTestEmailType(e.target.value)}
                            style="padding: 0.5rem; border-radius: 4px; border: 1px solid #dee2e6;"
                        >
                            <option value="new-booking">Neue Buchung (Bestätigung)</option>
                            <option value="no-show">Nicht erschienen (Nachfass-Mail)</option>
                            <option value="update-booking">Buchungs-Update</option>
                            <option value="admin-cancellation">Admin-Stornierung</option>
                        </select>
                        <button type="submit" class="btn btn-secondary btn-small" disabled=${isSendingTest}>
                            ${isSendingTest ? 'Sendet...' : 'Test-Mail senden'}
                        </button>
                    </form>
                    ${testMessage.text && html`
                        <p class="message ${testMessage.type === 'error' ? 'error-message' : 'success-message'}">
                            ${testMessage.text}
                        </p>
                    `}
                </div>
            `}
            ${eventsWithBookings.length === 0 ? html`<p class="empty-state">Keine relevanten Events mit Buchungen gefunden.</p>` :
            eventsWithBookings.map(event => {
                const participants = event.bookings_events
                    .map(be => be.bookings)
                    .filter(booking => booking && booking.customers);
                
                const categoryClass = `event-category-${event.category.toLowerCase()}`;
                const eventDate = new Date(event.date);
                const isPastOneHour = new Date() > new Date(eventDate.getTime() + 60 * 60 * 1000);

                return html`
                    <div class="overview-event-group" key=${event.id}>
                        <div class=${`overview-event-header ${categoryClass}`}>
                            <div class="overview-event-info">
                                <strong class="overview-event-title">${event.title}</strong>
                                <span class="overview-event-details">${formatDate(eventDate)} - ${formatTime(eventDate)}</span>
                                <span class="overview-event-details">Treffpunkt: ${event.location}</span>
                            </div>
                            <div class="overview-event-capacity">
                                ${event.booked_capacity} / ${event.total_capacity} Plätze
                            </div>
                        </div>

                        ${event.trainer ? html`
                            <div class="overview-event-trainer">
                                <span>Trainer: <strong>${event.trainer}</strong></span>
                            </div>
                        ` : html`
                            <div class="overview-event-trainer no-trainer-assigned">
                                <span>Kein Trainer zugewiesen</span>
                            </div>
                        `}

                        ${participants.length > 0 ? html`
                            <ul class="participant-list">
                                ${participants.map(booking => {
                                    const customer = booking.customers;
                                    const sentKey = `${event.id}-${customer.id}`;
                                    const emailSent = sentEmails.has(sentKey);
                                    
                                    return html`
                                    <li key=${customer.id}>
                                        <div class="participant-info">
                                            <strong>${customer.name}</strong> (Hund: ${customer.dog_name})
                                        </div>
                                        <div class="participant-contact">
                                            <span>${customer.email}</span>
                                            <span>${customer.phone}</span>
                                        </div>
                                        <div class="participant-actions">
                                            ${isPastOneHour && html`
                                                ${emailSent ? html`
                                                    <button class="btn btn-success btn-small" disabled>✔️ Mail gesendet</button>
                                                ` : html`
                                                    <button class="btn btn-warning btn-small" onClick=${() => handleOpenConfirmation(customer, event)}>
                                                        Nicht erschienen
                                                    </button>
                                                `}
                                            `}
                                            ${userRole === 'admin' && html`
                                                 <button class="btn btn-danger btn-small" onClick=${() => handleOpenCancelModal(booking, customer, event)}>
                                                    Stornieren
                                                </button>
                                            `}
                                        </div>
                                    </li>
                                `})}
                            </ul>
                        ` : html`
                            <p class="no-participants-message">Für dieses Event gibt es noch keine Anmeldungen.</p>
                        `}
                    </div>
                `;
            })}
        </div>
        <${ConfirmActionModal} 
            isOpen=${confirmModalState.isOpen}
            onClose=${handleCloseConfirmation}
            onConfirm=${handleSendNoShowEmail}
            title="Bestätigung erforderlich"
            message=${`Möchtest du wirklich eine 'Nicht erschienen'-Mail an ${confirmModalState.data?.customer.name} senden?`}
            confirmText="Ja, E-Mail senden"
            loading=${isSending}
            error=${confirmModalState.error}
        />
        <${ConfirmActionModal} 
            isOpen=${cancelModalState.isOpen}
            onClose=${handleCloseCancelModal}
            onConfirm=${handleConfirmAdminCancel}
            title="Buchung stornieren"
            message=${`Möchtest du die Buchung von ${cancelModalState.data?.customer.name} für "${cancelModalState.data?.event.title}" wirklich stornieren? Der Kunde erhält eine Bestätigungs-E-Mail.`}
            confirmText="Ja, stornieren"
            loading=${cancelModalState.loading}
            error=${cancelModalState.error}
        />
    `;
};

const CsvImportModal = ({ onImport, onClose }) => {
    const [file, setFile] = useState(null);
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);
    const [successMessage, setSuccessMessage] = useState('');
    const fileInputRef = useRef(null);

    const handleFileChange = (e) => {
        setFile(e.target.files[0]);
        setError('');
        setSuccessMessage('');
    };

    const handleImportClick = async () => {
        if (!file) {
            setError('Bitte wähle eine CSV-Datei aus.');
            return;
        }
        setLoading(true);
        setError('');
        setSuccessMessage('');

        const reader = new FileReader();
        reader.onload = async (e) => {
            const text = e.target.result;
            try {
                const parsedEvents = parseCsv(text);
                if (parsedEvents.length === 0) {
                    throw new Error("Die CSV-Datei ist leer oder enthält keine validen Datenzeilen.");
                }
                await onImport(parsedEvents);
                setSuccessMessage(`${parsedEvents.length} Events erfolgreich importiert!`);
                setFile(null);
                if(fileInputRef.current) fileInputRef.current.value = "";
            } catch (err) {
                setError(err.message);
            } finally {
                setLoading(false);
            }
        };
        reader.onerror = () => {
             setError("Fehler beim Lesen der Datei.");
             setLoading(false);
        };
        reader.readAsText(file);
    };

    const parseCsv = (csvText) => {
        const lines = csvText.trim().split(/\r?\n/).filter(line => line.trim());
        if (lines.length < 2) {
            throw new Error("CSV-Datei muss eine Kopfzeile und mindestens eine Datenzeile enthalten.");
        }

        const header = lines.shift().trim().toLowerCase();
        const expectedHeader = "datum,uhrzeit,titel,treffpunkt,plätze,kategorie";
        if (header !== expectedHeader) {
            throw new Error(`Falsche Kopfzeile. Erwartet: "datum,uhrzeit,titel,treffpunkt,plätze,kategorie"`);
        }
        
        const events = [];
        const errors = [];
        
        lines.forEach((line, index) => {
            const values = line.split(',');
            if (values.length !== 6) {
                errors.push(`Zeile ${index + 2}: Falsche Spaltenanzahl. Erwartet 6, gefunden ${values.length}.`);
                return;
            }
            
            const [dateStr, timeStr, title, location, capacityStr, category] = values.map(v => v.trim());

            if (!dateStr || !timeStr || !title || !capacityStr || !category) {
                 errors.push(`Zeile ${index + 2}: Ein oder mehrere Felder sind leer. Alle Felder außer Treffpunkt sind erforderlich.`);
                 return;
            }

            const combinedDate = new Date(`${dateStr}T${timeStr}`);
            if (isNaN(combinedDate.getTime())) {
                errors.push(`Zeile ${index + 2}: Ungültiges Datum/Uhrzeit-Format. Bitte JJJJ-MM-TT und HH:MM verwenden.`);
                return;
            }

            const totalCapacity = parseInt(capacityStr, 10);
            if (isNaN(totalCapacity) || totalCapacity < 1) {
                errors.push(`Zeile ${index + 2}: "Plätze" muss eine Zahl größer 0 sein.`);
                return;
            }

            if (!Object.keys(EVENT_CATEGORIES).includes(category)) {
                 errors.push(`Zeile ${index + 2}: Unbekannte Kategorie "${category}". Gültige Kategorien sind: ${Object.keys(EVENT_CATEGORIES).join(', ')}`);
                 return;
            }
            
            events.push({
                date: combinedDate,
                title,
                location: location || "Hundeplatz Ascha",
                totalCapacity,
                category
            });
        });
        
        if (errors.length > 0) {
            throw new Error("Fehler in der CSV-Datei:\n" + errors.join('\n'));
        }
        
        return events;
    };
    
    return html`
        <div class="modal-overlay" onClick=${onClose}>
            <div class="modal-content" onClick=${e => e.stopPropagation()}>
                <div class="modal-header">
                    <h2>Events per CSV importieren</h2>
                    <button type="button" class="modal-close-btn" onClick=${onClose} aria-label="Schließen">×</button>
                </div>
                <div class="modal-body">
                    <p>Lade eine CSV-Datei hoch, um mehrere Events auf einmal zu erstellen.</p>
                    <div class="csv-instructions">
                        <strong>Anforderungen:</strong>
                        <ul>
                            <li>Die Datei muss im CSV-Format sein (komma-getrennt).</li>
                            <li>Die erste Zeile muss die exakte Kopfzeile sein: <code>datum,uhrzeit,titel,treffpunkt,plätze,kategorie</code></li>
                            <li>Datumsformat: <code>JJJJ-MM-TT</code></li>
                            <li>Uhrzeitformat: <code>HH:MM</code> (24-Stunden)</li>
                        </ul>
                        <strong>Beispiel:</strong>
                        <pre><code>datum,uhrzeit,titel,treffpunkt,plätze,kategorie\n2025-10-28,16:00,Welpenstunde,Welpenwiese,8,Orchid\n2025-10-29,18:30,L2 - Grundlagen,,6,LimeGreen</code></pre>
                        <p><small>Wenn der Treffpunkt leer gelassen wird, wird "Hundeplatz Ascha" als Standard verwendet.</small></p>
                    </div>

                    <div class="form-group">
                        <label for="csv-file">CSV-Datei auswählen</label>
                        <input type="file" id="csv-file" name="csv-file" accept=".csv" onChange=${handleFileChange} ref=${fileInputRef} />
                    </div>

                    ${error && html`<p class="error-message" style=${{whiteSpace: 'pre-wrap'}}>${error}</p>`}
                    ${successMessage && html`<p class="success-message">${successMessage}</p>`}
                </div>
                <div class="modal-footer">
                     <button type="button" class="btn btn-secondary" onClick=${onClose} disabled=${loading}>Schließen</button>
                     <button type="button" class="btn btn-primary" onClick=${handleImportClick} disabled=${loading || !file}>
                        ${loading ? 'Importiert...' : 'Importieren'}
                     </button>
                </div>
            </div>
        </div>
    `;
};

const LiveStatusManager = () => {
    const [status, setStatus] = useState<'active' | 'cancelled' | 'partial'>('active');
    const [message, setMessage] = useState('');
    const [loading, setLoading] = useState(true);
    const [saving, setSaving] = useState(false);
    const [error, setError] = useState('');
    const [success, setSuccess] = useState(false);

    useEffect(() => {
        const fetchStatus = async () => {
            setLoading(true);
            const currentStatus = await api.getAppStatus();
            if (currentStatus) {
                setStatus(currentStatus.status);
                setMessage(currentStatus.message || '');
            }
            setLoading(false);
        };
        fetchStatus();
    }, []);

    const handleSave = async (e) => {
        e.preventDefault();
        setSaving(true);
        setError('');
        setSuccess(false);
        try {
            await api.updateAppStatus(status, message);
            setSuccess(true);
            setTimeout(() => setSuccess(false), 3000); // Hide success message after 3s
        } catch (err) {
            const errorMessage = (err instanceof Error) ? err.message : String(err);
            setError(errorMessage);
        } finally {
            setSaving(false);
        }
    };

    if (loading) {
        return html`<div class="loading-state">Lade Live-Status...</div>`;
    }

    return html`
        <div class="live-status-manager">
            <h2>Live-Status Steuerung</h2>
            <p>Ändere hier den globalen Status der App. Die Änderung wird allen Kunden in Echtzeit angezeigt.</p>
            <form onSubmit=${handleSave}>
                <div class="status-selection">
                    <button 
                        type="button" 
                        class=${`btn ${status === 'active' ? 'btn-success' : 'btn-secondary'}`}
                        onClick=${() => setStatus('active')}
                    >
                        Status 'aktiv'
                    </button>
                    <button 
                        type="button" 
                        class=${`btn ${status === 'partial' ? 'btn-warning' : 'btn-secondary'}`}
                        onClick=${() => setStatus('partial')}
                    >
                        Status 'mit Einschränkungen'
                    </button>
                    <button 
                        type="button" 
                        class=${`btn ${status === 'cancelled' ? 'btn-danger' : 'btn-secondary'}`}
                        onClick=${() => setStatus('cancelled')}
                    >
                        Status 'unterbrochen'
                    </button>
                </div>
                <div class="form-group">
                    <label for="status-message">Optionale Nachricht (wird den Kunden angezeigt)</label>
                    <textarea 
                        id="status-message" 
                        value=${message}
                        onInput=${e => setMessage(e.target.value)}
                        placeholder=${
                            status === 'active' ? 'Standard: Alle Stunden finden wie geplant statt.' :
                            status === 'partial' ? 'z.B. Welpenstunde findet statt, Level 2 fällt aus.' :
                            'Standard: Die Hundeschule fällt aus.'
                        }
                    ></textarea>
                </div>
                <div class="form-footer">
                    <button type="submit" class="btn btn-primary" disabled=${saving}>
                        ${saving ? 'Speichert...' : 'Live-Status aktualisieren'}
                    </button>
                    ${error && html`<p class="error-message">${error}</p>`}
                    ${success && html`<p class="success-message">Status erfolgreich aktualisiert!</p>`}
                </div>
            </form>
        </div>
    `;
};


const AdminPanel = ({ userRole }) => {
    const [events, setEvents] = useState([]);
    const [loading, setLoading] = useState(true);
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [isCsvModalOpen, setIsCsvModalOpen] = useState(false);
    const [editingEvent, setEditingEvent] = useState(null);
    const [deletingEventId, setDeletingEventId] = useState(null);
    const [deleteError, setDeleteError] = useState('');
    const [deleteLoading, setDeleteLoading] = useState(false);
    const [activeTab, setActiveTab] = useState('overview'); // 'overview', 'events', 'status'
    const [cleanupLoading, setCleanupLoading] = useState(false);
    const [cleanupMessage, setCleanupMessage] = useState({ text: '', type: '' });
    const [isConfirmingCleanup, setIsConfirmingCleanup] = useState(false);

    const loadEvents = async () => {
        setLoading(true);
        const eventsFromApi = await api.getEvents();
        const today = new Date();
        const startOfToday = new Date(today.getFullYear(), today.getMonth(), today.getDate());
        const futureEvents = eventsFromApi.filter(e => new Date(e.date) >= startOfToday);
        setEvents(futureEvents);
        setLoading(false);
    };

    useEffect(() => {
        if (activeTab === 'events') {
            loadEvents();
        }
    }, [activeTab]);

    const handleAdd = () => {
        setEditingEvent(null);
        setIsModalOpen(true);
    };

    const handleEdit = (event) => {
        setEditingEvent(event);
        setIsModalOpen(true);
    };

    const handleCopy = (eventToCopy) => {
        const newDate = new Date(eventToCopy.date);
        newDate.setDate(newDate.getDate() + 7); // Setzt das Datum auf eine Woche später
        setEditingEvent({ ...eventToCopy, date: newDate, id: null });
        setIsModalOpen(true);
    };

    const handleStartDelete = (eventId) => {
        setDeleteError('');
        setDeletingEventId(eventId);
    };

    const handleCancelDelete = () => {
        setDeletingEventId(null);
    };

    const handleConfirmDelete = async () => {
        if (!deletingEventId) return;
        setDeleteLoading(true);
        setDeleteError('');
        try {
            await api.deleteEvent(deletingEventId);
            setDeletingEventId(null);
            loadEvents();
        } catch (err) {
            setDeleteError(err.message);
        } finally {
            setDeleteLoading(false);
        }
    };
    
    const handleStartCleanup = () => {
        setCleanupMessage({ text: '', type: '' });
        setIsConfirmingCleanup(true);
    };
    
    const handleConfirmCleanup = async () => {
        setIsConfirmingCleanup(false);
        setCleanupLoading(true);
        try {
            const result = await api.cleanupOldEvents();
            setCleanupMessage({ 
                text: `${result.deletedCount ?? 0} vergangene(s) Event(s) wurde(n) erfolgreich entfernt.`,
                type: 'success'
            });
        } catch (err) {
            setCleanupMessage({ text: `Fehler: ${err.message}`, type: 'error' });
        } finally {
            setCleanupLoading(false);
        }
    };

    const handleSave = async (eventData) => {
        const finalEventData = { ...eventData };

        // Wenn kein Treffpunkt angegeben wurde oder er leer ist, setze den Standardwert.
        if (!finalEventData.location || finalEventData.location.trim() === '') {
            finalEventData.location = "Hundeplatz Ascha";
        }

        if (editingEvent && editingEvent.id) {
            await api.updateEvent(editingEvent.id, finalEventData);
        } else {
            await api.addEvent(finalEventData);
        }
        setIsModalOpen(false);
        setEditingEvent(null);
        loadEvents();
    };
    
    const handleCsvImport = async (eventsToImport) => {
        // Die Funktion wird an das Modal übergeben. Fehlerbehandlung findet im Modal statt.
        // Bei Erfolg wird das Modal geschlossen und die Eventliste neu geladen.
        await api.addEvents(eventsToImport);
        setIsCsvModalOpen(false);
        loadEvents();
    };

    return html`
        <section class="admin-panel">
            <div class="admin-tabs">
                <button 
                    class=${`btn ${activeTab === 'overview' ? 'btn-primary' : 'btn-secondary'}`}
                    onClick=${() => setActiveTab('overview')}
                >Buchungsübersicht</button>
                <button 
                    class=${`btn ${activeTab === 'events' ? 'btn-primary' : 'btn-secondary'}`}
                    onClick=${() => setActiveTab('events')}
                >Event Verwaltung</button>
                <button 
                    class=${`btn ${activeTab === 'status' ? 'btn-primary' : 'btn-secondary'}`}
                    onClick=${() => setActiveTab('status')}
                >Live-Status</button>
            </div>

            ${activeTab === 'overview' && html`<${BookingOverview} userRole=${userRole} />`}
            ${activeTab === 'status' && html`<${LiveStatusManager} />`}

            ${activeTab === 'events' && html`
                <div class="event-management-view">
                    <div class="admin-header">
                        <h2>Event Verwaltung</h2>
                        <div class="admin-header-actions">
                            <button class="btn btn-primary" onClick=${handleAdd}>+ Neues Event</button>
                            <button class="btn btn-secondary" onClick=${() => setIsCsvModalOpen(true)}>CSV Import</button>
                            <div class="cleanup-container">
                                <div class="cleanup-control">
                                    ${cleanupLoading ? html`
                                        <div class="admin-cleanup-progress progress-indicator">
                                            <span class="progress-indicator-label">Lösche alte Events...</span>
                                            <div class="progress-bar-container">
                                                <div class="progress-bar"></div>
                                            </div>
                                        </div>
                                    ` : isConfirmingCleanup ? html`
                                        <div class="confirm-cleanup-actions">
                                            <span>Sicher?</span>
                                            <button class="btn btn-secondary" onClick=${() => setIsConfirmingCleanup(false)}>Abbrechen</button>
                                            <button class="btn btn-danger" onClick=${handleConfirmCleanup}>Ja, löschen</button>
                                        </div>
                                    ` : html`
                                        <button class="btn btn-danger" onClick=${handleStartCleanup}>
                                            Alte Events löschen
                                        </button>
                                    `}
                                </div>
                                ${cleanupMessage.text && html`
                                    <p class="cleanup-message ${cleanupMessage.type === 'error' ? 'error-message' : 'success-message'}">
                                        ${cleanupMessage.text}
                                    </p>
                                `}
                            </div>
                        </div>
                    </div>
                     ${loading ? html`<div class="loading-state">Lade Events...</div>` : html`
                        <ul class="admin-event-list">
                            ${events.map(event => html`
                                <li key=${event.id} class=${`admin-event-item event-category-${event.category.toLowerCase()}`}>
                                   <div class="admin-event-info">
                                        <strong>${event.title}</strong>
                                        <span>${formatDate(new Date(event.date))} - ${formatTime(new Date(event.date))}</span>
                                        <span>Treffpunkt: ${event.location}</span>
                                        <span>Plätze: ${event.booked_capacity} / ${event.total_capacity}</span>
                                   </div>
                                   ${event.trainer ? html`
                                        <div class="admin-event-trainer">
                                            <span>Trainer: <strong>${event.trainer}</strong></span>
                                        </div>
                                   ` : html`
                                        <div class="admin-event-trainer no-trainer-assigned">
                                            <span>Kein Trainer zugewiesen</span>
                                        </div>
                                   `}
                                   <div class="admin-event-actions">
                                       <button class="btn btn-secondary" onClick=${() => handleEdit(event)}>Bearbeiten</button>
                                       <button class="btn btn-secondary" onClick=${() => handleCopy(event)}>Kopieren</button>
                                       <button 
                                            class="btn btn-danger" 
                                            onClick=${() => handleStartDelete(event.id)}
                                            disabled=${event.booked_capacity > 0}
                                            title=${event.booked_capacity > 0 ? 'Event hat Buchungen und kann nicht gelöscht werden' : 'Event löschen'}
                                       >Löschen</button>
                                   </div>
                                </li>
                            `)}
                        </ul>
                    `}
                </div>
            `}
        </section>
        ${isModalOpen && html`
            <${EventFormModal} 
                event=${editingEvent}
                onSave=${handleSave}
                onClose=${() => setIsModalOpen(false)}
            />
        `}
        ${deletingEventId && html`
            <${ConfirmDeleteModal} 
                onConfirm=${handleConfirmDelete}
                onClose=${handleCancelDelete}
                error=${deleteError}
                loading=${deleteLoading}
            />
        `}
        ${isCsvModalOpen && html`
            <${CsvImportModal}
                onImport=${handleCsvImport}
                onClose=${() => setIsCsvModalOpen(false)}
            />
        `}
    `;
};

const BookingManagementPortal = ({ setView, initialBookingId }) => {
    const [bookingIdInput, setBookingIdInput] = useState(initialBookingId || '');
    const [booking, setBooking] = useState<Booking | null>(null);
    const [allEvents, setAllEvents] = useState<Event[]>([]);
    const [managedEventIds, setManagedEventIds] = useState<string[]>([]);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState<string | any>('');
    const [successMessage, setSuccessMessage] = useState('');
    const [hasChanges, setHasChanges] = useState(false);
    const [isForgotModalOpen, setIsForgotModalOpen] = useState(false);
    const [updateComplete, setUpdateComplete] = useState(false);

    const performLookup = async (idToLookup: string) => {
        if (!idToLookup) return;
        setError('');
        setSuccessMessage('');
        setIsLoading(true);
        setBooking(null);
        try {
            const foundBooking = await api.getBookingById(idToLookup.trim());
            if (foundBooking) {
                setBooking(foundBooking);
                setManagedEventIds(foundBooking.bookedEventIds);
            } else {
                setError('Buchung nicht gefunden. Bitte überprüfe deine Eingabe.');
            }
        } catch (err) {
            setError(err.message);
        } finally {
            setIsLoading(false);
        }
    };

    useEffect(() => {
        if (initialBookingId) {
            performLookup(initialBookingId);
        }
    }, [initialBookingId]);

    useEffect(() => {
        if (booking) {
            setIsLoading(true);
            api.getEvents().then(events => {
                setAllEvents(events.map(e => ({...e, date: new Date(e.date)})));
                setIsLoading(false);
            });
        }
    }, [booking]);

    useEffect(() => {
        if (booking) {
            setHasChanges(JSON.stringify(booking.bookedEventIds.sort()) !== JSON.stringify(managedEventIds.sort()));
        } else {
            setHasChanges(false);
        }
    }, [managedEventIds, booking]);

    const handleLookupSubmit = async (e) => {
        e.preventDefault();
        performLookup(bookingIdInput);
    };

    const handleSaveChanges = async () => {
        if (!booking) return;
        setError('');
        setSuccessMessage('');
        setIsLoading(true);
        try {
            const updatedBooking = await api.updateBooking(booking.bookingId, managedEventIds);
            setBooking(updatedBooking); // update local state with the saved data
            setManagedEventIds(updatedBooking.bookedEventIds);
            setUpdateComplete(true);

            // E-Mail-Versand für Update anstoßen
            try {
                const updatedEventsDetails = allEvents
                    .filter(event => updatedBooking.bookedEventIds.includes(event.id))
                    .map(e => ({
                        title: e.title,
                        date: new Date(e.date).toLocaleString('de-DE', { dateStyle: 'full', timeStyle: 'short' }) + ' Uhr',
                        location: e.location,
                        category: e.category
                    }));
                
                await supabase.functions.invoke('send-smtp-email', {
                    body: {
                        type: 'update-booking',
                        customerName: updatedBooking.customer.name,
                        customerEmail: updatedBooking.customer.email,
                        bookingId: updatedBooking.bookingId,
                        events: updatedEventsDetails
                    }
                });
            } catch (emailError) {
                console.warn("E-Mail-Funktion konnte nicht aufgerufen werden. Stelle sicher, dass die Supabase Edge Function 'send-smtp-email' deployed ist.", emailError);
            }

        } catch (err) {
            setError(err.message);
        } finally {
            setIsLoading(false);
        }
    };

    const handleEventToggle = (eventId: string) => {
        setManagedEventIds(prev =>
            prev.includes(eventId) ? prev.filter(id => id !== eventId) : [...prev, eventId]
        );
    };
    
    const handleReset = () => {
        setBooking(null);
        setBookingIdInput('');
        setUpdateComplete(false);
        setError('');
        setSuccessMessage('');
    }

    const { bookedEvents, availableEvents } = useMemo(() => {
        if (!booking) return { bookedEvents: [], availableEvents: [] };
        const now = new Date(); // Exact current time

        const booked = allEvents
            .filter(e => managedEventIds.includes(e.id) && new Date(e.date) > now) // Strictly future events
            .sort((a, b) => a.date.getTime() - b.date.getTime());

        const available = allEvents
            .filter(e => {
                if (managedEventIds.includes(e.id)) return false;
                if (new Date(e.date) <= now) return false; // Strictly future events
                if (e.booked_capacity >= e.total_capacity) return false;
                return true;
            })
            .sort((a, b) => a.date.getTime() - b.date.getTime());
        return { bookedEvents: booked, availableEvents: available };
    }, [allEvents, managedEventIds, booking]);

    if (updateComplete) {
        return html`
            <section class="manage-portal-success">
                <h2>Änderungen gespeichert!</h2>
                <p class="success-message">Deine Buchung wurde erfolgreich aktualisiert. Wir haben dir eine Bestätigungs-E-Mail gesendet.</p>
                <div class="manage-footer">
                    <button class="btn btn-secondary" onClick=${() => setView('booking')}>Zurück zur Eventliste</button>
                    <button class="btn btn-primary" onClick=${handleReset}>Andere Buchung verwalten</button>
                </div>
            </section>
        `;
    }

    if (!booking) {
        return html`
            <section class="booking-lookup-form">
                <form onSubmit=${handleLookupSubmit}>
                    <h2>Meine Buchungen verwalten</h2>
                    <p>Gib eine deiner Buchungsnummern ein, um deine Termine zu bearbeiten.</p>
                    <div class="form-group">
                        <label for="bookingId">Buchungsnummer</label>
                        <input type="text" id="bookingId" name="bookingId" value=${bookingIdInput} onInput=${e => setBookingIdInput(e.target.value)} required placeholder="z.B. Bello-12345" />
                    </div>
                    ${error && html`<div class="error-message">${error}</div>`}
                    <button type="submit" class="btn btn-primary" disabled=${isLoading}>
                        ${isLoading ? 'Sucht...' : 'Buchung suchen'}
                    </button>
                </form>
                 <button class="forgot-booking-id-btn" onClick=${() => setIsForgotModalOpen(true)}>
                    Buchungsnummer vergessen?
                </button>
            </section>
            ${isForgotModalOpen && html`<${ForgotPasswordModal} onClose=${() => setIsForgotModalOpen(false)} />`}
        `;
    }

    return html`
       <section class="manage-portal">
            <h2>Buchungsübersicht für ${booking.customer.name}</h2>
            <p>Buchungsnummer: <strong>${booking.bookingId}</strong></p>
            
            ${error && html`<div class="error-message">${error}</div>`}
            ${successMessage && html`<p class="success-message">${successMessage}</p>`}

            <div class="manage-container">
                <div class="manage-section">
                    <h3>Deine gebuchten Events</h3>
                    ${bookedEvents.length > 0 ? html`
                        <ul class="manage-event-list">
                            ${bookedEvents.map(event => {
                                const hoursUntil = (event.date.getTime() - new Date().getTime()) / (1000 * 60 * 60);
                                const canCancel = hoursUntil >= CANCELLATION_WINDOW_HOURS;
                                const categoryClass = `event-category-${event.category.toLowerCase()}`;
                                return html`
                                    <li key=${event.id} class=${`manage-event-item ${categoryClass}`}>
                                        <div class="manage-event-details">
                                            <strong>${event.title}</strong>
                                            <span>${formatDate(event.date)} - ${formatTime(event.date)}</span>
                                            <span>Treffpunkt: ${event.location}</span>
                                            ${!canCancel && html`<small class="cancel-warning">Stornierung nicht mehr möglich</small>`}
                                        </div>
                                        <button class="btn btn-danger" onClick=${() => handleEventToggle(event.id)} disabled=${!canCancel}>Stornieren</button>
                                    </li>
                                `;
                            })}
                        </ul>
                    ` : html`<p class="empty-state-small">Du hast aktuell keine Events gebucht.</p>`}
                </div>
                <div class="manage-section">
                    <h3>Verfügbare Events</h3>
                     ${availableEvents.length > 0 ? html`
                        <ul class="manage-event-list">
                            ${availableEvents.map(event => {
                                const categoryClass = `event-category-${event.category.toLowerCase()}`;
                                return html`
                                     <li key=${event.id} class=${`manage-event-item ${categoryClass}`}>
                                        <div class="manage-event-details">
                                            <strong>${event.title}</strong>
                                            <span>${formatDate(event.date)} - ${formatTime(event.date)}</span>
                                            <span>Treffpunkt: ${event.location}</span>
                                            <small>${event.total_capacity - event.booked_capacity} Plätze frei</small>
                                        </div>
                                        <button class="btn btn-success" onClick=${() => handleEventToggle(event.id)}>Buchen</button>
                                    </li>
                                `;
                            })}
                        </ul>
                    ` : html`<p class="empty-state-small">Aktuell sind keine weiteren Events verfügbar.</p>`}
                </div>
            </div>
            <div class="manage-footer">
                <button class="btn btn-secondary" onClick=${handleReset}>Andere Buchung suchen</button>
                <button class="btn btn-primary" onClick=${handleSaveChanges} disabled=${!hasChanges || isLoading}>
                    ${isLoading ? 'Speichert...' : 'Änderungen speichern'}
                </button>
            </div>
       </section>
    `;
};


const CustomerBookingView = ({ setView }) => {
    const [allEvents, setAllEvents] = useState<Event[]>([]);
    const [loading, setLoading] = useState(true);
    const [selectedEventIds, setSelectedEventIds] = useState<string[]>([]);
    const [customer, setCustomer] = useState<Omit<Customer, 'id'>>({ name: '', phone: '', dog_name: '', email: '' });
    const [bookingError, setBookingError] = useState('');
    const [agreedAGB, setAgreedAGB] = useState(false);
    const [agreedPrivacy, setAgreedPrivacy] = useState(false);
    const [bookingSuccess, setBookingSuccess] = useState(false);
    const [successfulBookingDetails, setSuccessfulBookingDetails] = useState(null);
    const [isEmailExistsModalOpen, setIsEmailExistsModalOpen] = useState(false);
    const [isForgotModalOpen, setIsForgotModalOpen] = useState(false);
    const [appStatus, setAppStatus] = useState<AppStatus | null>(null);

    const loadInitialData = async () => {
        setLoading(true);
        try {
            const events = await api.getEvents();
            setAllEvents(events);
        } catch (error) {
            setBookingError("Fehler beim Laden der Events. Bitte versuche es später erneut.");
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        loadInitialData();
        
        // Fetch initial status and subscribe to realtime updates
        api.getAppStatus()
           .then(setAppStatus)
           .catch(err => {
                console.error("Could not load initial app status. Make sure the 'app_status' table was created correctly via the SQL Editor.", err.message);
                // Optionally set an error state to show in the UI
           });

        const channel = api.subscribeToAppStatus((newStatus) => {
            setAppStatus(newStatus);
        });

        // Cleanup subscription on component unmount
        return () => {
            if (channel) {
                supabase.removeChannel(channel);
            }
        };
    }, []);

    const handleSelectEvent = (eventId: string) => {
        setSelectedEventIds(prev =>
            prev.includes(eventId) ? prev.filter(id => id !== eventId) : [...prev, eventId]
        );
    };
    
    const handleCloseModal = () => {
        setBookingSuccess(false);
        setSuccessfulBookingDetails(null);
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setBookingError('');
        try {
            const booking = await api.saveBooking(customer, selectedEventIds);
            setSuccessfulBookingDetails({ bookingId: booking.bookingId, customerName: customer.name });
            setBookingSuccess(true);
            
            // E-Mail-Versand anstoßen
            try {
                const bookedEventsDetails = allEvents
                    .filter(event => selectedEventIds.includes(event.id))
                    .map(e => ({
                        title: e.title,
                        date: new Date(e.date).toLocaleString('de-DE', { dateStyle: 'full', timeStyle: 'short' }) + ' Uhr',
                        location: e.location,
                        category: e.category
                    }));

                await supabase.functions.invoke('send-smtp-email', {
                    body: {
                        type: 'new-booking',
                        customerName: customer.name,
                        customerEmail: customer.email,
                        bookingId: booking.bookingId,
                        events: bookedEventsDetails
                    }
                });
            } catch (emailError) {
                console.warn("E-Mail-Funktion konnte nicht aufgerufen werden. Stelle sicher, dass die Supabase Edge Function 'send-smtp-email' deployed ist.", emailError);
            }

            // Immediately reload events to show updated capacity from the database trigger
            loadInitialData();

            // Reset state after successful booking
            setSelectedEventIds([]);
            setCustomer({ name: '', phone: '', dog_name: '', email: '' });
            setAgreedAGB(false);
            setAgreedPrivacy(false);

        } catch (err) {
            if (err.message.includes('Für diese E-Mail-Adresse existiert bereits eine Buchung')) {
                setIsEmailExistsModalOpen(true);
            } else {
                setBookingError(err.message);
            }
        }
    }
    
    const { eventsByWeek, selectedEvents } = useMemo(() => {
        const now = new Date();
        const futureEvents = allEvents
            .filter(event => event.date > now)
            .sort((a, b) => a.date.getTime() - b.date.getTime());

        // Linear grouping to preserve chronological order and handle year boundaries correctly
        const eventsByWeek = [];
        let currentGroup = null;
        let lastKey = '';

        futureEvents.forEach(event => {
            // Calculate ISO Week Year to differentiate between Dec 2024 (KW 1 of 2025) and Dec 2024 (KW 52 of 2024)
            const d = new Date(Date.UTC(event.date.getFullYear(), event.date.getMonth(), event.date.getDate()));
            d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
            const isoYear = d.getUTCFullYear();
            const week = getWeekNumber(event.date);
            
            const key = `${isoYear}-${week}`;

            if (key !== lastKey) {
                lastKey = key;
                currentGroup = {
                    weekHeader: `${formatMonthYear(event.date)} - Kalenderwoche ${week}`,
                    events: []
                };
                eventsByWeek.push(currentGroup);
            }
            if (currentGroup) {
                currentGroup.events.push(event);
            }
        });
        
        const selectedEvents = allEvents.filter(event => selectedEventIds.includes(event.id)).sort((a,b) => a.date.getTime() - b.date.getTime());
            
        return { eventsByWeek, selectedEvents };
    }, [allEvents, selectedEventIds]);

    if (loading) {
        return html`<div class="loading-state">Lade Eventtermine...</div>`;
    }
    
    const today = new Date();
    const startOfToday = new Date(today.getFullYear(), today.getMonth(), today.getDate());
    
    return html`
        <main class="main-container">
            <section class="events-section">
                <${LiveStatusBanner} statusData=${appStatus} />
                <div class="events-container-box">
                    <div class="month-navigator">
                        <h2>Eventliste Hundeschule</h2>
                    </div>
                    <${EventLegend} />
                    <div class="event-list-container">
                        ${eventsByWeek.length > 0 ? eventsByWeek.map(weekGroup => html`
                            <div class="week-group" key=${weekGroup.weekHeader}>
                                <h3 class="week-header">${weekGroup.weekHeader}</h3>
                                <ul class="event-list">
                                    ${weekGroup.events.map(event => {
                                        const isPast = event.date < new Date();
                                        return html`
                                        <${EventItem} 
                                            key=${event.id}
                                            event=${event}
                                            onSelect=${handleSelectEvent}
                                            isSelected=${selectedEventIds.includes(event.id)}
                                            isLocked=${isPast}
                                        />
                                    `})}
                                </ul>
                            </div>
                        `) : html`
                            <p class="empty-state">Aktuell gibt es keine verfügbaren Events.</p>
                        `}
                    </div>
                </div>
            </section>
            
            <aside class="booking-section">
                <${BookingPanel} 
                    selectedEvents=${selectedEvents}
                    customer=${customer}
                    onCustomerChange=${setCustomer}
                    onSubmit=${handleSubmit}
                    error=${bookingError}
                    agreedAGB=${agreedAGB}
                    onAgreedAGBChange=${setAgreedAGB}
                    agreedPrivacy=${agreedPrivacy}
                    onAgreedPrivacyChange=${setAgreedPrivacy}
                />
            </aside>
        </main>
        ${bookingSuccess && html`
            <${SuccessModal} 
                bookingDetails=${successfulBookingDetails}
                onClose=${handleCloseModal}
            />
        `}
        ${isEmailExistsModalOpen && html`
            <${EmailExistsModal} 
                email=${customer.email}
                onClose=${() => setIsEmailExistsModalOpen(false)}
                onGoToManage=${() => {
                    setIsEmailExistsModalOpen(false);
                    setView('manage');
                }}
                onForgotPassword=${() => {
                    setIsEmailExistsModalOpen(false);
                    setIsForgotModalOpen(true);
                }}
            />
        `}
        ${isForgotModalOpen && html`
            <${ForgotPasswordModal} 
                onClose=${() => setIsForgotModalOpen(false)}
            />
        `}
    `;
};

const AdminLoginModal = ({ onClose, initialError }) => {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState(initialError || '');
    const [loading, setLoading] = useState(false);

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        setLoading(true);
        
        const { error: signInError } = await supabase.auth.signInWithPassword({
            email: email,
            password: password,
        });
        
        setLoading(false);

        if (signInError) {
            setError('Falsche E-Mail-Adresse oder Passwort.');
        } else {
            // Success is handled by the onAuthStateChange listener in the App component.
            onClose();
        }
    };

    return html`
        <div class="modal-overlay" onClick=${onClose}>
            <div class="modal-content" onClick=${e => e.stopPropagation()}>
                <form onSubmit=${handleSubmit}>
                    <div class="modal-header">
                        <h2>Mitarbeiter Login</h2>
                        <button type="button" class="modal-close-btn" onClick=${onClose} aria-label="Schließen">×</button>
                    </div>
                    <div class="modal-body">
                        ${error && html`<p class="error-message">${error}</p>`}
                        <div class="form-group">
                            <label for="admin-email">E-Mail</label>
                            <input type="email" id="admin-email" name="email" value=${email} onInput=${e => setEmail(e.target.value)} required autocomplete="email" />
                        </div>
                        <div class="form-group">
                            <label for="admin-password">Passwort</label>
                            <input type="password" id="admin-password" name="password" value=${password} onInput=${e => setPassword(e.target.value)} required autocomplete="current-password" />
                        </div>
                    </div>
                    <div class="modal-footer">
                         <button type="button" class="btn btn-secondary" onClick=${onClose} disabled=${loading}>Abbrechen</button>
                         <button type="submit" class="btn btn-primary" disabled=${loading}>${loading ? 'Logge ein...' : 'Login'}</button>
                    </div>
                </form>
            </div>
        </div>
    `;
};

const App = () => {
    const [view, setView] = useState('booking');
    const [session, setSession] = useState<Session | null>(null);
    const [userRole, setUserRole] = useState<string | null>(null);
    const [isLoginModalOpen, setIsLoginModalOpen] = useState(false);
    const [loginError, setLoginError] = useState('');
    const [initialBookingId, setInitialBookingId] = useState<string | null>(null);
    const [installPromptEvent, setInstallPromptEvent] = useState(null);
    const [promoModalData, setPromoModalData] = useState<PromoModalData | null>(null);
    const [isPromoModalOpen, setIsPromoModalOpen] = useState(false);


    useEffect(() => {
        // --- Promo Modal Logic ---
        const checkPromoModal = async () => {
            const data = await api.getPromoModal();
            if (data) {
                const lastSeenTimestamp = localStorage.getItem('seenPromoModalTimestamp');
                if (!lastSeenTimestamp || new Date(data.updated_at) > new Date(lastSeenTimestamp)) {
                    setPromoModalData(data);
                    setIsPromoModalOpen(true);
                }
            }
        };
        checkPromoModal();

        // Service Worker Registration for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed: ', error);
                    });
            });
        }
        
        // --- PWA Installation Prompt Handling ---
        const handleBeforeInstallPrompt = (e) => {
            // Prevent the mini-infobar from appearing on mobile.
            e.preventDefault();
            // Stash the event so it can be triggered later.
            setInstallPromptEvent(e);
            console.log("'beforeinstallprompt' event was fired.");
        };

        const handleAppInstalled = () => {
            console.log('PWA was installed');
            // Hide the install button as it's no longer needed
            setInstallPromptEvent(null);
        };

        window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
        window.addEventListener('appinstalled', handleAppInstalled);

        
        // Handle URL parameters for direct linking
        const params = new URLSearchParams(window.location.search);
        const viewParam = params.get('view');
        const bookingIdParam = params.get('bookingId');
        if (viewParam === 'manage' && bookingIdParam) {
            setView('manage');
            setInitialBookingId(bookingIdParam);
        } else if (viewParam === 'monitor') {
            setView('monitor');
        }

        // Fetch the initial session
        supabase.auth.getSession().then(({ data: { session } }) => {
            setSession(session);
            setUserRole(session?.user?.user_metadata?.role ?? null);
        });

        // Listen for changes in auth state (login, logout)
        const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
            setSession(session);
            // Get role from metadata. You need to set this in Supabase Auth > Users > User Management
            setUserRole(session?.user?.user_metadata?.role ?? null);
            if (session) { // If a session is established (login successful)
                setIsLoginModalOpen(false);
                // Check current URL param to decide view
                const params = new URLSearchParams(window.location.search);
                if (params.get('view') === 'monitor') {
                    setView('monitor');
                } else {
                    setView('admin'); // Automatically switch to admin view on login otherwise
                }
            }
        });
        
        // Global listener for authentication errors (e.g., expired session)
        const handleAuthError = async (e: CustomEvent) => {
            const { data: { session } } = await supabase.auth.getSession();
            if (session) {
                await supabase.auth.signOut();
            }
            setLoginError(e.detail.message);
            setIsLoginModalOpen(true);
            setView('booking'); // Reset view to default
        };
        
        window.addEventListener('auth-error', handleAuthError);


        // Cleanup subscription on component unmount
        return () => {
            subscription.unsubscribe();
            window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
            window.removeEventListener('appinstalled', handleAppInstalled);
            window.removeEventListener('auth-error', handleAuthError);
        };
    }, []);


    const handleLogout = async () => {
        await supabase.auth.signOut();
        setUserRole(null);
        setView('booking');
    };

    const handleInstallClick = async () => {
        if (!installPromptEvent) {
            return;
        }
        // Show the native installation prompt
        installPromptEvent.prompt();
        // Wait for the user to respond to the prompt
        const { outcome } = await installPromptEvent.userChoice;
        console.log(`User response to the install prompt: ${outcome}`);
        // We've used the prompt, and can't use it again. Clear it.
        setInstallPromptEvent(null);
    };
    
    const handleClosePromoModal = () => {
        if (promoModalData) {
            localStorage.setItem('seenPromoModalTimestamp', promoModalData.updated_at);
        }
        setIsPromoModalOpen(false);
    };

    if (view === 'monitor') {
        if (!session) {
             return html`
                <div class="monitor-login-wrapper">
                    <${AdminLoginModal} 
                        onClose=${() => setView('booking')} 
                        initialError="Bitte einloggen für Monitor-Modus" 
                    />
                </div>
             `;
        }
        return html`<${MonitorView} />`;
    }

    return html`
        <header class="booking-tool-header">
            <div class="header-content">
                <div 
                    class=${`logo-container ${installPromptEvent ? 'installable' : ''}`}
                    onClick=${installPromptEvent ? handleInstallClick : null}
                    title=${installPromptEvent ? 'App auf diesem Gerät installieren' : ''}
                >
                    <img src="https://hs-bw.com/wp-content/uploads/2025/10/Pfoten-Card-Icon.png" alt="Pfoten-Event Logo" class="header-logo" />
                    ${installPromptEvent && html`
                        <span class="install-prompt-text">App installieren</span>
                    `}
                </div>
                <div class="header-text">
                    <h1>Pfoten-Event</h1>
                    <p>Wähle deine Wunschtermine, verwalte deine Buchungen</p>
                </div>
            </div>
            
            <${AppSwitcher} />

            <nav class="main-nav">
                <button class=${`btn ${view === 'booking' ? 'btn-primary' : 'btn-secondary'}`} onClick=${() => setView('booking')}>Buchungsansicht</button>
                <button class=${`btn ${view === 'manage' ? 'btn-primary' : 'btn-secondary'}`} onClick=${() => setView('manage')}>Meine Buchungen verwalten</button>
                ${session && html`
                    <button class=${`btn ${view === 'admin' ? 'btn-primary' : 'btn-secondary'}`} onClick=${() => setView('admin')}>Mitarbeiter-Panel</button>
                    <button class="btn btn-secondary" onClick=${handleLogout}>Logout</button>
                `}
            </nav>
        </header>

        <main>
            ${view === 'booking' && html`<${CustomerBookingView} setView=${setView} />`}
            ${view === 'manage' && html`<${BookingManagementPortal} setView=${setView} initialBookingId=${initialBookingId} />`}
            
            ${session && view === 'admin' && (userRole === 'admin' || userRole === 'mitarbeiter') && html`
                <${AdminPanel} userRole=${userRole} />
            `}
        </main>
        
        ${!session && html`
            <footer class="app-footer">
                <button class="admin-login-btn" onClick=${() => setIsLoginModalOpen(true)}>Mitarbeiter Login</button>
            </footer>
        `}

        ${isLoginModalOpen && html`
            <${AdminLoginModal} 
                onClose=${() => {
                    setIsLoginModalOpen(false);
                    setLoginError('');
                }}
                initialError=${loginError}
            />
        `}
        
        ${isPromoModalOpen && promoModalData && html`
            <${PromoModal}
                data=${promoModalData}
                onClose=${handleClosePromoModal}
            />
        `}
    `;
};


render(html`<${App} />`, document.getElementById('app'));
